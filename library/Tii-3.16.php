<?php
/**
 * !!! AUTOMATICALLY GENERATED FILE. DO NOT MODIFY !!!
 *
 * @link http://www.tiiframework.com/
 * @copyright Copyright (c) 2005 Alacner Zhang <alacner@gmail.com>
 * @license http://www.tiiframework.com/license/
 */
 error_reporting(0); version_compare(PHP_VERSION, '5.4.0', '>=') || die('require PHP > 5.4.0 !'); ini_set('magic_quotes_runtime', 0); define('TII_DIRECTORY', __DIR__); defined('TII_SAPI') || define('TII_SAPI', PHP_SAPI); defined('TII_PROCESSOR') || define('TII_PROCESSOR', 'Tii_Application_Processor_' . ucfirst(in_array(TII_SAPI, ['cli', 'mock']) ? TII_SAPI : 'http') ); if (!function_exists('boolval')) { function boolval($i) { return (bool) $i;}} final class Tii { private static $initialTime = 0; private static $previousTime = 0; public static function className() { return ucwords(implode('_', func_get_args()), '_'); } public static function usage($i = false) { self::$initialTime || self::$initialTime = microtime(true); self::$previousTime || self::$previousTime = self::$initialTime; $i1 = microtime(true); $i2 = $i1 - self::$previousTime; self::$previousTime = $i1; $i3 = new stdClass(); $i3->initialTime = self::$initialTime; $i3->presentTime = $i1; $i3->consumedTime = $i2; $i3->totalConsumedTime = ($i1 - self::$initialTime); $i3->memory = memory_get_usage(true); if ($i) return $i3; $i3->memoryPeak = memory_get_peak_usage(true); $i3->loadavg = sys_getloadavg(); return $i3; } public static function call($i, $i1 = []) { if (is_array($i)) { try { list($i2, $i3) = $i; $i4 = new ReflectionClass($i2); $i5 = $i4->getMethod($i3); $i5->setAccessible(true); return $i5->invokeArgs($i2, $i1); } catch (Exception $i6) { } } return call_user_func_array($i, $i1); } public static function object() { static $i = []; $i1 = func_get_args(); $i1 || die(Tii::lang("%s: illegal arguments", __METHOD__)); $i2 = $i3 = array_shift($i1); if (is_array($i3)) return call_user_func_array('static::object', $i3); if (is_object($i3)) return $i3; $i1 && $i2 .= '#'.Tii_Math::toGuidString($i1); if (isset($i[$i2])) return $i[$i2]; $i4 = false; if ($i3{0} == '@') { $i4 = true; $i3 = substr($i3, 1); } if ($i1) { $i5 = new ReflectionClass($i3); $i6 = $i5->newInstanceArgs($i1); } else { $i6 = new $i3; } $i[$i2] = $i4 ? new Tii_Delegate($i6) : $i6; return $i[$i2]; } public static function objective($i, $i1) { array_unshift($i1, $i); return self::object($i1); } public static function buffer($i, $i1) { static $i2 = []; $i3 = func_get_args(); $i = array_shift($i3); $i1 = array_shift($i3); isset($i2[$i]) || $i2[$i] = call_user_func_array($i1, $i3); return $i2[$i]; } public static function filename($i, $i1, $i2 = '', $i3 = '', $i4 = '', $i5 = NULL) { $i5 || $i5 = Tii::get('tii.application.directory'); empty($i3) || $i3 = "." . $i3; return Tii_Event::filter('tii.filename', is_array($i5) ? Tii_Filesystem::concat( self::valueInArray($i5, $i), $i1, $i4, $i2 . $i3 ) : Tii_Filesystem::concat( $i5, $i1, $i, $i4, $i2 . $i3 ), $i, $i1, $i2, $i3, $i4); } public static function setter(array &$i, $i1, $i2, $i3 = '.') { if (is_null($i1)) return $i = $i2; $i4 = explode($i3, $i1); while (count($i4) > 1) { $i1 = array_shift($i4); if (!isset($i[$i1]) || !is_array($i[$i1])) { $i[$i1] = []; } $i =& $i[$i1]; } $i[array_shift($i4)] = $i2; return $i; } public static function getter($i, $i1, $i2 = NULL, $i3 = '.') { if (is_null($i1)) return $i; if (isset($i[$i1])) return $i[$i1]; list ($i4, $i1) = array_pad(explode($i3, $i1, 2), 2, NULL); if (!isset($i[$i4]) || !$i1 || !is_array($i[$i4])) return $i2; if (isset($i[$i4][$i1])) return $i[$i4][$i1]; return static::getter($i[$i4], $i1, $i2); } public static function render($i, array $i1 = []) { preg_match_all("|\{([^{}]+)\}|iUs", $i, $i2); if (empty($i2)) return $i; $i3 = []; foreach($i2[1] as $i4) { $i5 = self::getter($i1, $i4); $i3[] = is_scalar($i5) ? $i5 : serialize($i5); } return str_replace($i2[0], $i3, $i); } public static function validator($i = [], $i1 = [], $i2 = [], $i3 = [], $i4 = true) { static $i5 = NULL; if (is_null($i5)) { $i5 = Tii_Event::filter('tii.validators', Tii::get("tii.validators", [])); $i5 = array_merge($i5, [ 'required' => function($i6, $i7) { return isset($i6[$i7]); }, 'not_empty' => function($i6, $i7) { $i8 = self::valueInArray($i6, $i7); if (is_object($i8) && $i8 instanceof ArrayObject) { $i8 = $i8->getArrayCopy(); } return !in_array($i8, [NULL, false, '', []], true); }, 'regex' => function($i6, $i7, $i9, $iA) { return preg_match($i9, strval($i6[$i7])); }, 'equals' => function($i6, $i7, $iB) { return ($i6[$i7] === $iB); }, 'date' => function($i6, $i7) { return (strtotime($i6[$i7]) !== false); }, ]); } $iC = []; if (is_array($i) && is_array($i1)) { foreach($i1 as $i7 => $iD) { is_array($iD) || $iD = [$iD]; foreach($iD as $iE => $iF) { if (is_numeric($iE)) { $iE = $iF; $iF = []; } if (!isset($i5[$iE])) { if (function_exists($iE)) { $i5[$iE] = function($i, $iG) use ($iE, $iF) { array_unshift($iF, $i[$iG]); return call_user_func_array($iE, $iF); }; } else { $iC[] = Tii::lang("validator `%s' not found", $iE); continue; } } array_unshift($iF, $i, $i7); $iH = false; try { if (!call_user_func_array($i5[$iE], $iF)) { $iH = true; $iI = $i3[$iE]?:Tii::get( Tii_Config::_lang("tii.validator.messages.$iE"), Tii::lang("{0} didn't pass the validator `%s'", $iE) ); } } catch (Exception $iJ) { $iH = true; $iI = $iJ->getMessage(); } if ($iH) { $iC[$i7] = self::render( $iI, [$i2[$i7]?:Tii::get(Tii_Config::_lang("tii.validator.alias.$i7"), $i7), $iF] ); break; } } } } else { $iC[] = Tii::lang("validation data,rules must be an array"); } if ($i4 && count($iC)) { throw new Tii_Exception(implode(";", $iC)); } return $iC; } public static function value($i, $i1 = NULL) { return $i ?: $i1; } public static function valueInArray($i, $i1, $i2 = NULL) { return isset($i[$i1]) ? $i[$i1] : $i2; } public static function unshiftkv(array &$i, $i1, $i2) { $i = array_reverse($i, true); $i[$i1] = $i2; $i = array_reverse($i, true); return count($i); } public static function pop($i, $i1 = false) { $i2 = NULL; $i1 && shuffle($i); while(is_array($i) && $i && (!$i2 = array_pop($i))); return $i2; } public static function combine(array $i, $i1 = NULL, $i2 = NULL) { $i3 = []; if (empty($i)) return $i3; if ($i1 || $i2) { array_map($i2 ? function($i4) use (&$i3, $i2, $i1) { $i4 = (array) $i4; isset($i4[$i2]) && $i3[$i4[$i2]] = $i1 ? $i4[$i1] : $i4; } : function(array $i4) use (&$i3, $i1) { $i4 = (array) $i4; $i3[] = $i4[$i1]; }, $i); } else { $i5 = array_keys($i); $i6 = array_pop($i5); foreach($i[$i6] as $i7 => $i8) { $i3[$i7][$i6] = $i8; foreach($i5 as $i9) { $i3[$i7][$i9] = $i[$i9][$i7]; } } } return $i3; } public static function combiner() { $i = func_get_args(); $i1 = array_shift($i); $i2 = count($i); $i3 = count($i1); if ($i2 > $i3) { $i = array_slice($i, 0, $i3); } else if ($i2 < $i3) { $i1 = array_slice($i1, 0, $i2); } return array_combine($i, $i1); } public static function separate(array $i, $i1, $i2) { $i3 = []; array_walk($i, function($i4, $i5) use (&$i3, $i1, $i2) { $i3[] = [$i1 => $i5, $i2 => $i4]; }); return $i3; } public static function _constants($i = NULL, $i1 = NULL) { static $i2; if (!isset($i2[$i][$i1])) { if ($i) { $i3 = new ReflectionClass($i); $i4 = $i3->getConstants(); } else { $i4 = get_defined_constants(); } if ($i1) { $i5 = []; foreach($i4 as $i6 => $i7) { if ($i1 && !preg_match($i1, $i6)) continue; $i5[$i6] = $i7; } $i4 = $i5; } $i2[$i][$i1] = [$i4, array_flip($i4)]; } return $i2[$i][$i1]; } public static function constants($i = NULL, $i1 = NULL, $i2 = true) { return Tii::valueInArray(self::_constants($i, $i1), intval($i2), []); } public static function properties($i = NULL, $i1 = NULL) { static $i2; if (empty($i)) return []; if (!isset($i2[$i][$i1])) { $i3 = new ReflectionClass($i); $i4 = self::combine($i3->getProperties(), 'name'); if ($i1) { $i5 = []; foreach($i4 as $i6) { if ($i1 && !preg_match($i1, $i6)) continue; $i5[] = $i6; } $i4 = $i5; } $i2[$i][$i1] = $i4; } return $i2[$i][$i1]; } public static function filter() { static $i; $i || $i = [ '#' => 'intval', '!' => 'boolval', '.' => 'floatval', '*' => 'strval', '>' => 'json_encode', '<' => function($i1){return json_decode($i1, true);}, '+' => 'serialize', '-' => 'unserialize', ]; $i2 = func_get_args(); $i3 = array_shift($i2); if (is_array($i3)) { $i4 = $i3; $i3 = "isset"; } else { $i4 = array_shift($i2); } if (!is_array($i4)) return []; if (!is_callable($i3)){ switch($i3) { case 'not_empty': $i3 = function($i4, $i5){return !empty($i4[$i5]);}; break; default: $i3 = function($i4, $i5){ return isset($i4[$i5]);}; } } $i6 = []; foreach($i2 as $i7) { is_array($i7) || $i7 = [$i7]; foreach($i7 as $i5) { if (isset($i[$i5{0}])) { $i8 = $i[$i5{0}]; $i5 = substr($i5, 1); if (call_user_func($i3, $i4, $i5)) { $i6[$i5] = call_user_func($i8, $i4[$i5]); } } else { if (call_user_func($i3, $i4, $i5)) { $i6[$i5] = $i4[$i5]; } } } } return $i6; } public static function exec() { $i = microtime(true); $i1 = new stdClass(); $i1->command = trim(call_user_func_array('sprintf', func_get_args())); preg_match('| 2[^>]*>[^>]*&1$|', $i1->command) || $i1->command .= ' 2>&1'; $i1->status = 1; $i2 = []; exec($i1->command, $i2, $i1->status); $i1->succeed = !$i1->status; $i1->output = implode(PHP_EOL, $i2); $i1->duration = microtime(true) - $i; return $i1; } public static function explode($i, $i1, $i2 = true, $i3 = true, $i4 = true) { $i5 = explode($i, $i1); if ($i2) { if ($i2 === true) { $i2 = 'trim'; } elseif (!is_callable($i2)) { $i2 = function ($i6) use ($i2) { return trim($i6, $i2); }; } $i5 = array_map($i2, $i5); } if ($i3) { $i5 = array_values(array_filter($i5, function ($i7) { return $i7 !== ''; })); } return $i4 ? array_unique($i5) : $i5; } public static function __callStatic($i, $i1) { static $i2 = []; if (isset($i2[$i])) return $i2[$i]; if (preg_match('/get(.*)Helper/i', $i, $i3)) { if (empty($i3[1])) { $i2[$i] = Tii::object('@Tii_Application_Helper'); } else { $i2[$i] = Tii::object('@Tii_Application_Helper', $i3[1]); } return $i2[$i]; } foreach(['Tii_Config', 'Tii_Security_Encryption'] as $i4) { if (method_exists($i4, $i)) { return call_user_func_array([$i4, $i], $i1); } } } } spl_autoload_register(function($i) { $i1 = strpos($i, '_'); if ($i1 !== false) { $i2 = substr($i, 0, $i1); switch ($i2) { case 'Tii' : $i3 = TII_DIRECTORY; break; default: $i3 = Tii::get(sprintf('tii.library.%s', $i2)); if (empty($i3) && ($i4 = Tii::get('tii.library.*'))) { $i4 = $i4 . DIRECTORY_SEPARATOR . ucfirst($i2); is_dir($i4) && $i3 = $i4; } if (empty($i3) && !is_dir($i3 = Tii::filename('library', lcfirst($i2)))) { throw new Tii_Exception("class `%s' not found", $i); } if (!is_dir($i3)) { throw new Tii_Exception("include directory `%s' not exist", $i3); } break; } $i5 = $i3 . str_replace('_', DIRECTORY_SEPARATOR, strstr($i, '_')) . '.php'; if (is_file($i5)) require_once $i5; } else { include_once str_replace('\\', DIRECTORY_SEPARATOR, $i) . '.php'; } }); set_error_handler(function() { $i = func_get_args(); array_unshift($i, 'tii.error.handler'); return call_user_func_array('Tii_Event::action', $i); }); set_exception_handler(function($i) { Tii_Event::action('tii.exception.handler', $i); }); register_shutdown_function(function(){ Tii_Event::action('tii.shutdown.handler'); }); Tii::usage(); Tii_Event::register('tii.error.handler', 'Tii_Exception::set_error_handler', 0); Tii_Event::register('tii.exception.handler', function($i) { call_user_func('Tii_Exception::set_exception_handler', $i); return true; }, 0); Tii_Event::register('tii.shutdown.handler', function() { $i = error_get_last(); if (empty($i)) return true; Tii_Exception::set_error_handler($i['type'], $i['message'], $i['file'], $i['line']); restore_error_handler(); return true; }, 0); 
 final class Tii_Version { const VERSION = '3.16.1027.1005'; }
 class Tii_ConfigWrapper { public function __construct() { foreach(func_get_args() as $i) { $i1 = gettype($i); switch($i1) { case 'object': $i = get_object_vars($i); case 'array': foreach($i as $i2 => $i3) { $this->{$i2} = $i3; } break; default: Tii_Logger::debug(Tii::lang("wrapper only allow array or object but got %s", $i1)); } } } }
 class Tii_Exception extends Exception { public function __construct() { $i = func_get_args(); $i1 = call_user_func_array('Tii::lang', $i); $i2 = -1 * Tii_Math::hashStr(Tii::valueInArray($i, 0, ''), false); parent::__construct($i1, $i2); } public static function set_error_handler($i, $i1, $i2, $i3, array $i4 = []) { $i5 = func_get_args(); switch ($i) { case E_ERROR: case E_PARSE: case E_STRICT: case E_USER_ERROR: echo "<br />\n<b>Fatal error</b>:  $i1 in <b>$i2</b> on line <b>$i3</b><br />"; Tii_Logger::err($i1, $i5); exit; break; case E_WARNING: case E_USER_WARNING: Tii_Logger::warn($i1, $i5); break; case E_NOTICE: case E_USER_NOTICE: Tii_Logger::notice($i1, $i5); break; case E_DEPRECATED: case E_USER_DEPRECATED: Tii_Logger::info($i1, $i5); break; default: Tii_Logger::debug($i1, $i5); break; } return true; } public static function set_error_exception_handler($i, $i1, $i2, $i3, array $i4 = []) { throw new ErrorException($i1, $i, 0, $i2, $i3); } public static function set_exception_handler($i) { throw new Exception($i->getMessage(), $i->getCode(), $i); } }
 class Tii_Application_Exception extends Tii_Exception {}
 class Tii_Application_IgnoreException extends Tii_Application_Exception {}
 class Tii_Application_Controller_Exception extends Tii_Application_Exception { }
 class Tii_Dao_Exception extends Tii_Exception {}
 abstract class Tii_Logger_Abstract { protected $priority = Tii_Logger_Constant::ERR; protected $priorities = []; protected $priorityNames = []; public function __construct() { list($this->priorities, $this->priorityNames) = Tii::_constants('Tii_Logger_Constant'); } public function setPriority($priority = Tii_Logger_Constant::ERR) { $this->priority = $priority; } public function getPriority() { return $this->priority; } public function __call($i, $i1) { list($i2, $i3) = array_pad($i1, 2, NULL); $priority = Tii::valueInArray($this->priorities, strtoupper($i), Tii_Logger_Constant::ALL); Tii_Logger::$print && printf("[%s] %s\n", $i, $i2); $priority > Tii_Logger::$print_backtrace_priority || debug_print_backtrace(); if ($priority > $this->priority) return false; try { return call_user_func([$this, 'doLog'], $i2, $priority, $i3); } catch (Exception $i4) { trigger_error("send the log records failed: " . $i4->getMessage(), E_USER_NOTICE); return false; } } public function getPriorityName($priority) { return Tii::valueInArray($this->priorityNames, $priority); } abstract public function doLog($message, $priority = Tii_Logger_Constant::ERR, $extras = NULL); }
 abstract class Tii_Cache_Abstract { abstract public function isSupported(); abstract public function set($key, $var, $compress = 0, $expire = 0); abstract public function add($key, $var, $compress = 0, $expire = 0); abstract public function replace($key, $var, $compress = 0, $expire = 0); abstract public function increment($key, $value = 1); abstract public function decrement($key, $value = 1); abstract public function get($key); abstract public function delete($key, $timeout=0); abstract public function lock($key, $expire = 60); abstract public function unlock($key); abstract public function flush(); }
 abstract class Tii_Application_Abstract { public function __call($i, $i1) { if (is_callable([Tii_Application::getInstance(), $i])) { return call_user_func_array([Tii_Application::getInstance(), $i], $i1); } } public function __get($i) { $i1 = $this->getProcessor()->getRequest($i); if (is_null($i1)) { throw new Tii_Application_Controller_Exception("parameter `%s' not exist", $i); } return $i1; } public function __set($i, $i1 = NULL) { $this->getProcessor()->{$i} = $i1; } public function has($i) { return !is_null($this->getProcessor()->getRequest($i)); } }
 abstract class Tii_Application_Processor_Abstract { private $interrupt = false; private $vars = []; private $moduleName; private $controllerName; private $actionName; public function __construct() { $this->busyError(); $this->setModuleName($this->getDefaultModuleName()); $this->setControllerName($this->getDefaultControllerName()); $this->setActionName($this->getDefaultActionName()); } protected function busyError() { $i = Tii::get('tii.application.server.busy_error.loadctrl', 0); if ($i && $i1 = sys_getloadavg()) { if ($i1[0] > $i) $this->doBusyError($i, $i1[0]); } } public function isInterrupt() { return $this->interrupt; } public function setInterrupt($interrupt = true) { $this->interrupt = $interrupt; return $this; } public function getProcessorName() { $i = new ReflectionClass($this); return strtolower(substr(strrchr($i->getShortName(), "_"), 1)); } public function getDefaultModuleName() { return Tii::get('tii.application.module'); } public function getDefaultControllerName() { return Tii::get('tii.application.controller'); } public function getDefaultActionName() { return Tii::get('tii.application.action'); } public function setModuleName($i) { $this->moduleName = $i; return $this; } public function getModuleName() { return $this->moduleName ?: $this->getDefaultModuleName(); } public function setControllerName($i) { $this->controllerName = $i; return $this; } public function getControllerName() { return $this->controllerName ?: $this->getDefaultControllerName(); } public function setActionName($i) { $this->actionName = $i; return $this; } public function getActionName() { return $this->actionName ?: $this->getDefaultActionName(); } public function getDispatcher() { return Tii_Application::getInstance(); } public function getRequestTimeFloat() { return $_SERVER['REQUEST_TIME_FLOAT'] ?: Tii_Time::micro(); } public function getRequestTime() { return $_SERVER['REQUEST_TIME'] ?: Tii_Time::now(); } public function setPair($i, $i1 = NULL, $i2 = '_') { $this->vars[$i2][$i] = $i1; return $this; } public function setPairs($vars, $i = '_') { $this->vars[$i] = $vars; return $this; } public function getPair($i, $i1 = NULL, $i2 = '_') { return isset($this->vars[$i2][$i]) ? $this->vars[$i2][$i] : $i1; } public function getPairs($i = [], $i1 = '_') { return isset($this->vars[$i1]) ? $this->vars[$i1] : $i; } public function forward($i = NULL, $i1 = NULL, $i2 = NULL) { $this->getDispatcher()->execute($i, $i1, $i2); return $this; } public function lang() { return call_user_func_array('Tii_Config::lang', func_get_args()); } public function __call($i, $i1) { if (preg_match('/get(.*)Helper/i', $i)) { return call_user_func('Tii::' . $i); } else if (is_callable([$this->getResponse(), $i])) { return call_user_func_array([$this->getResponse(), $i], $i1); } } abstract protected function doBusyError($loadctrl, $load); abstract public function over(); abstract public function getRequest($name, $default = NULL); abstract public function getRequests(); abstract public function getResponse(); }
 abstract class Tii_Application_Helper_Pager_Abstract extends Tii_Application_Abstract { protected $options = [ 'num' => 0, 'perpage' => 10, 'curpage' => 1, 'mpurl' => '', 'ext' => '', 'page' => 10, ]; public function __construct(array $options = []) { $this->options = array_merge($this->options, $options); $this->filter(); } abstract public function render(); protected function filter() { if ($this->options['num'] > $this->options['perpage']) { $i = 2; $i1 = @ceil($this->options['num'] / $this->options['perpage']); if ($this->options['page'] > $i1) { $i2 = 1; $i3 = $i1; } else { $i2 = $this->options['curpage'] - $i; $i3 = $i2 + $this->options['page'] - 1; if ($i2 < 1) { $i3 = $this->options['curpage'] + 1 - $i2; $i2 = 1; if ($i3 - $i2 < $this->options['page']) { $i3 = $this->options['page']; } } else if($i3 > $i1) { $i2 = $i1 - $this->options['page'] + 1; $i3 = $i1; } } $this->options['offset'] = $i; $this->options['pages'] = $i1; $this->options['from'] = $i2; $this->options['to'] = $i3; } } }
 abstract class Tii_Application_Controller_Abstract extends Tii_Application_Abstract { public function init() {} abstract public function indexAction(); public function over() {} public function error(Exception $i) { throw new Tii_Application_Controller_Exception($i->getMessage()); } }
 abstract class Tii_Application_Controller_ErrorAbstract extends Tii_Application_Controller_Abstract { public function indexAction() {} abstract public function errorAction(); }
 final class Tii_Event { private static $events = []; private static $files = []; private static $interrupts = []; public static function init() { $i = Tii::get('tii.application.filters', []); if (isset($i['*'])) { $i1 = $i['*']; is_array($i1) || $i1 = [$i1]; foreach($i1 as $i2) { if (is_dir($i2)) { foreach(Tii_Filesystem::getRelativePathFiles($i2, ['php']) as $i3) { list($i4) = Tii_Filesystem::explode(substr($i3, 0, -4)); Tii_Event::register($i4, Tii_Filesystem::concat($i2, $i3)); } } else { Tii_Logger::warn("filter directory `$i2' not exist"); } } unset($i['*']); } foreach($i as $i5 => $i6) { is_array($i6) || $i6 = [$i6]; foreach($i6 as $i7) { Tii_Event::register($i5, $i7); } } } public static function register($i, $i1 = NULL, $i2 = 1024) { if (is_callable($i1)) { self::$events[$i][$i2][] = $i1; krsort(self::$events[$i], SORT_NUMERIC); } else if (is_file($i1)) { self::$files[$i][] = $i1; } else { throw new Tii_Exception("register `%s' failed, invalid argument `callback'", $i); } return true; } private static function import($i) { if (!isset(self::$files[$i])) return NULL; $files = self::$files[$i]; foreach($files as $i1) { include_once $i1; } unset(self::$files[$i]); return $files; } public static function interrupt($i) { self::$interrupts[$i] = true; } public static function filter($i, $i1 = NULL) { $i2 = func_get_args(); $i = array_shift($i2); self::import($i); if (!isset(self::$events[$i])) return $i1; foreach (self::$events[$i] as $i3) { foreach ($i3 as $i4) { if (Tii::valueInArray(self::$interrupts, $i, false)) break 2; $i2[0] = call_user_func_array($i4, $i2); } } return $i2[0]; } public static function action() { $i = func_get_args(); $i1 = array_shift($i); self::import($i1); if (!isset(self::$events[$i1])) return NULL; $i2 = []; foreach (self::$events[$i1] as $i3) { foreach ($i3 as $i4) { if (Tii::valueInArray(self::$interrupts, $i1, false)) break 2; $i2[] = call_user_func_array($i4, $i); } } return $i2; } public static function destroy($i) { unset(self::$events[$i]); } }
 class Tii_Worker_Event { const EV_READ = 1; const EV_WRITE = 2; const EV_SIGNAL = 4; const EV_TIMER = 8; const EV_TIMER_ONCE = 16; public static function instance() { return Tii::object(Tii::className(__CLASS__, self::getDriverName())); } public static function getDriverName() { static $i; if ($i) return $i; $i = Tii::get('tii.worker.default_event', Tii_Worker::$init['default_event']); foreach (Tii::get('tii.worker.available_events', Tii_Worker::$init['available_events']) as $i1) { if (extension_loaded($i1)) { $i = $i1; break; } } return $i; } }
 abstract class Tii_Worker_Event_Abstract extends Tii_Worker_Event { protected $events = []; protected $signals = []; protected $timers = []; protected static $id = 1; abstract public function add($fd, $flag, $func, $args = []); abstract public function delete($fd, $flag); abstract public function clearAllTimer(); abstract public function loop(); }
 class Tii_Worker_Callable { public function __call($i, $i1) { if (preg_match('|^on[A-Z][a-z].+$|', $i)) { try { if (!$this->{$i}) return; array_unshift($i1, $this); call_user_func_array($this->{$i}, $i1); } catch (Exception $i2) { Tii_Logger::debug(get_called_class() . " call `$i' error: " . $i2->getMessage(), $i1); exit(250); } } } }
 class Tii_Worker_Connection extends Tii_Worker_Callable { public static $statistics = [ 'connection_count' => 0, 'total_request' => 0, 'throw_exception' => 0, 'send_fail' => 0, ]; }
 abstract class Tii_Worker_Connection_Abstract extends Tii_Worker_Connection { protected $socket = null; protected $remoteAddress = ''; public $protocol = null; public $onConnect; public $onMessage; public $onClose; public $onBufferFull; public $onBufferDrain; public $onError; public function __construct($socket, $i) { $this->socket = $socket; $this->remoteAddress = $i; } public function getRemoteAddress() { return $this->remoteAddress; } public function getRemoteIp() { $i = strrpos($this->remoteAddress, ':'); if ($i) { return trim(substr($this->remoteAddress, 0, $i), '[]'); } return ''; } public function getRemotePort() { if ($this->remoteAddress) { return (int)substr(strrchr($this->remoteAddress, ':'), 1); } return 0; } abstract public function send($buffer, $raw = false); abstract public function close($data = null); }
 class Tii_Service { public static function __callStatic($i, $i1) { $i2 = ($i{0} == strtoupper($i{0}) ? '' : '@') . get_called_class(); array_unshift($i1, Tii::className($i2, $i)); return Tii::object($i1); } } 
 final class Tii_Security_Filter { public static function htmlTags($i) { $i = preg_replace("/(javascript:)?on(click|load|key|mouse|error|abort|move|unload|change|dblclick|move|reset|resize|submit)/i", "&111n\\2", $i); $i = preg_replace("/<script(.*?)>(.*?)<\/script>/si", "", $i); $i = preg_replace("/<iframe(.*?)>(.*?)<\/iframe>/si", "", $i); $i = preg_replace ("/<object.+<\/object>/iesU", '', $i); return $i; } public static function htmlChars($i) { if (function_exists('htmlspecialchars')) return htmlspecialchars($i); return str_replace(["&", '"', "'", "<", ">"], ["&amp;", "&quot;", "&#039;", "&lt;", "&gt;"], $i); } public static function jsChars($i) { return str_replace(["\\", "'", "\"", "/", "\r", "\n"], ["\\x5C", "\\x27", "\\x22", "\\x2F", "\\x0D", "\\x0A"], $i); } public static function str($i, $i1 = false) { $i = preg_replace('/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/', '', $i); $i = str_replace(["\0","%00","\r"], '', $i); empty($i1) && $i = preg_replace("/&(?!(#[0-9]+|[a-z]+);)/si", '&', $i); $i = str_replace(["%3C", '<'], '<', $i); $i = str_replace(["%3E",'>'], '>', $i); $i = str_replace(['"', "'", "\t", ' '], ['“','‘',' ',' '], $i); return trim($i); } }
 final class Tii_Security_Encryption { private static $authcodeKey = NULL; public static function setAuthcodeKey($authcodeKey = '') { self::$authcodeKey = $authcodeKey; return true; } private static function getAuthcodeKey() { self::$authcodeKey || self::setAuthcodeKey(Tii::get('tii.auth_code_key', Tii_Config::getIdentifier())); return self::$authcodeKey; } private static function authcode($i, $i1 = 'DECODE', $i2 = '', $i3 = 0, $i4 = '') { $i5 = 4; $i2 = md5($i2 != '' ? $i2 : self::getAuthcodeKey()); $i6 = md5(substr($i2, 0, 16)); $i7 = md5(substr($i2, 16, 16)); $i8 = $i5 ? ($i1 == 'DECODE' ? substr($i, 0, $i5): substr(md5($i4), -$i5)) : ''; $i9 = $i6.md5($i6.$i8); $iA = strlen($i9); $i = $i1 == 'DECODE' ? self::urlsafeBase64Decode(substr($i, $i5)) : sprintf('%010d', $i3 ? $i3 + time() : 0).substr(md5($i.$i7), 0, 16).$i; $iB = strlen($i); $iC = ''; $iD = range(0, 255); $iE = []; for ($iF = 0; $iF < 256; $iF++) { $iE[$iF] = ord($i9[$iF % $iA]); } for ($iG = $iF = 0; $iF < 256; $iF++) { $iG = ($iG + $iD[$iF] + $iE[$iF]) % 256; $iH = $iD[$iF]; $iD[$iF] = $iD[$iG]; $iD[$iG] = $iH; } for ($iI = $iG = $iF = 0; $iF < $iB; $iF++) { $iI = ($iI + 1) % 256; $iG = ($iG + $iD[$iI]) % 256; $iH = $iD[$iI]; $iD[$iI] = $iD[$iG]; $iD[$iG] = $iH; $iC .= chr(ord($i[$iF]) ^ ($iD[($iD[$iI] + $iD[$iG]) % 256])); } if ($i1 == 'DECODE') { if (((int)substr($iC, 0, 10) == 0 || substr($iC, 0, 10) - time() > 0) && substr($iC, 10, 16) == substr(md5(substr($iC, 26).$i7), 0, 16)) { return substr($iC, 26); } else { return ''; } } else { return $i8.self::urlsafeBase64Encode($iC); } } public static function encode($i, $i1 = 0, $i2 = '') { return self::authcode($i, 'ENCODE', $i2, $i1, microtime()); } public static function encodeWithoutHash($i, $i1 = 0, $i2 = '') { return self::authcode($i, 'ENCODE', $i2, $i1, md5(md5(self::getAuthcodeKey()))); } public static function decode($i, $i1 = '') { return self::authcode($i, 'DECODE', $i1); } public static function urlsafeBase64Encode($i) { return str_replace(['+', '/', '='], ['-' ,'_', ''], base64_encode($i)); } public static function urlsafeBase64Decode($i) { $i1 = str_replace(['-', '_'], ['+', '/'], $i); $i2 = strlen($i1) % 4; if ($i2) { $i1 .= substr('====', $i2); } return base64_decode($i1); } }
 final class Tii_Packer { protected $directory; protected $output; protected $uglify = ""; protected $excludeVar = []; protected $priorities = []; protected $exclude = []; public function __construct($directory, $output, $i = true) { if (!is_dir($directory)) { throw new Tii_Exception("input directory not exist"); } if (is_file($output) && !$i) { throw new Tii_Exception("output file `%s' not exist", $output); } if (!Tii_Filesystem::touch($output)) { throw new Tii_Exception("output file `%s' un-writable", $output); } $this->directory = $directory; $this->output = $output; } public function priority() { $i = func_get_args(); $this->priorities = array_reverse($i); return $this; } public function setUglify($uglify) { $this->uglify = $uglify; } public function excludeVar() { $this->excludeVar = array_merge($this->excludeVar, func_get_args()); } public function exclude() { $exclude = [[], []]; foreach(func_get_args() as $i) { if (strpos($i, '*') === false) { $exclude[0][] = $i; } else { $exclude[1][] = '|^'.str_replace('\*', '.*', preg_quote($i, '|')).'|i'; } } $this->exclude = $exclude; } private function isExclude($i) { if (in_array($i, $this->exclude[0])) return true; foreach($this->exclude[1] as $i1) { if (preg_match($i1, $i)) { return true; } } return false; } public function execute($i = false, $i1 = NULL, $i2 = []) { $i3 = new SplPriorityQueue(); foreach(Tii_Filesystem::getRelativePathFiles($this->directory, ['php']) as $i4) { if ($this->isExclude($i4)) continue; $i5 = array_search($i4, $this->priorities); $i3->insert($i4, ($i5 === false) ? -1 : $i5); } $i3->setExtractFlags(SplPriorityQueue::EXTR_DATA); $i3->top(); while($i3->valid()){ $i4 = $i3->current(); $i && print_r("$i4\n"); $i2[] = call_user_func_array( is_callable($i1) ? $i1 : 'self::compilePHPFile', [Tii_Filesystem::concat($this->directory, $i4), $this->uglify, $this->excludeVar] ); $i3->next(); } $i2 = implode("\n", $i2); $i2 = str_replace("?>\n<?php", "\n", $i2); if ($this->uglify) $i2 = str_replace("\n\n", '', $i2); file_put_contents($this->output, $i2, LOCK_EX); $i && print("".$this->output."\n"); return true; } public static function compilePHPFile($i, $uglify = NULL, $i1 = []) { $i2 = file_get_contents($i); $i3 = ''; $i4 = token_get_all($i2); $i5 = false; $i6 = 0; for ($i7 = 0, $i8 = count ($i4); $i7 < $i8; $i7++) { if (is_string ($i4[$i7])) { $i5 = false; $i3 .= $i4[$i7]; } else { switch ($i4[$i7][0]) { case T_OPEN_TAG: $i6++; $i3 .= $i4[$i7][1]; break; case T_CLOSE_TAG: $i6--; $i3 .= $i4[$i7][1]; break; case T_COMMENT: case T_DOC_COMMENT: break; case T_WHITESPACE: if (!$i5) { $i3 .= ' '; $i5 = true; } break; default: $i5 = false; $i3 .= $i4[$i7][1]; } } } $i6 && $i3 .= "\n?>"; if (empty($uglify)) return $i3; $i4 = token_get_all($i3); $i3 = ''; $i1 = array_merge([ '$this', '$GLOBALS', '$_SERVER', '$_GET', '$_POST', '$_FILES', '$_REQUEST', '$_SESSION', '$HTTP_POST_VARS', '$HTTP_GET_VARS', '$HTTP_SESSION_VARS', '$HTTP_ENV_VARS', '$HTTP_COOKIE_VARS', '$HTTP_POST_FILES', '$HTTP_SERVER_VARS', '$HTTP_RAW_POST_DATA', '$_ENV', '$_COOKIE', '$php_errormsg', '$http_response_header', '$argc', '$argv', ], $i1); $i9 = 0; $iA = false; $iB = 0; $iC = 0; $iD = []; $iE = ''; for ($i7 = 0, $i8 = count($i4); $i7 < $i8; $i7++) { if (is_string ($i4[$i7])) { if ($i9 > 0) { $iE .= $i4[$i7]; switch($i4[$i7]) { case '{': $iA = true; $iB++; break; case '}': $iB--; break; default: } if ($iA && $iB === 0) { $i3 .= $iE; $iC = 0; $iD = []; $iE = ""; $iA = false; $i9 = 0; } } else { $i3 .= $i4[$i7]; } } else { switch ($i4[$i7][0]) { case T_CURLY_OPEN: $iB++; if ($i9 > 0) { $iE .= $i4[$i7][1]; } else { $i3 .= $i4[$i7][1]; } break; case T_VARIABLE: if ($i9 > 0) { if (in_array($i4[$i7][1], $i1)) { $iE .= $i4[$i7][1]; } else { if (!isset($iD[$i4[$i7][1]])) { while(($iF = '$'.$uglify.Tii_Math::decst($iC++)) && in_array($iF, $i1)) { } $iD[$i4[$i7][1]] = $iF; } $iE .= $iD[$i4[$i7][1]]; } } else { $i1[] = $i4[$i7][1]; $i3 .= $i4[$i7][1]; } break; case T_FUNCTION: if (strtolower($i4[$i7-2][1]) == 'abstract' || strtolower($i4[$i7-4][1]) == 'abstract') { $i3 .= $i4[$i7][1]; } else { $i9++; $iE .= $i4[$i7][1]; } break; default: if ($i9 > 0) { $iE .= $i4[$i7][1]; } else { $i3 .= $i4[$i7][1]; } } } } return $i3; } }
 final class Tii_Network { protected static $macPattern = "|([0-9a-f][0-9a-f][:-]){5}[0-9a-f][0-9a-f]|i"; protected static $ipPattern = "|([0-9]{1,3}\.){3}[0-9]{1,3}|i"; public static function getAvailablePort($i = 10000, $i1 = 20000) { while(true) { foreach(range($i, $i1) as $i2) { if (!fsockopen('127.0.0.1', $i2, $i3, $i4, 1)) return $i2; } sleep(1); } } private static function configParser($i = "", $i1 = [], $i2 = false) { static $i3; $i3 || @exec("ifconfig -a", $i3); $i3 || @exec("ipconfig /all", $i3); $i3 || $i3 = []; $i4 = []; foreach($i3 as $i5) { if (preg_match($i, $i5, $i6)) { if (in_array($i6[0], $i1)) continue; if ($i2) { return $i6[0]; } else { $i4[] = $i6[0]; } } } return $i4; } public static function getIp() { return self::configParser(self::$ipPattern, ["127.0.0.1"], true); } public static function getMacAddr() { return self::configParser(self::$macPattern, [], true); } public static function getMacAddrs() { return self::configParser(self::$macPattern); } public static function parseHost($i, $i1 = 22) { return array_pad(explode(':', $i), 2, $i1); } public static function getPort($i, $i1 = 22) { return preg_match('|:(\d+)$|', $i, $i2) ? $i2[1] : $i1; } public static function parseIpRange($i) { if (strpos($i, '*') !== false) { $i = sprintf('%s-%s', str_replace('*', '0', $i), str_replace('*', '255', $i)); } return (strpos($i, '-') !== false) ? explode('-', $i, 2) : [$i, $i]; } public static function ipInRange($i, $i1) { if (strpos($i1, '/') !== false) { list($i1, $i2) = explode('/', $i1, 2); if (strpos($i2, '.') !== false) { $i2 = str_replace('*', '0', $i2); $i3 = ip2long($i2); return ((ip2long($i) & $i3) === (ip2long($i1) & $i3)); } else { $i4 = array_map(function($i5){return empty($i5) ? '0' : $i5;}, array_pad(explode('.', $i1), 4, 0)); array_unshift($i4, '%u.%u.%u.%u'); $i6 = ip2long(call_user_func_array('sprintf', $i4)); $i7 = ip2long($i); $i8 = pow(2, (32 - $i2)) - 1; $i3 = ~ $i8; return (($i7 & $i3) === ($i6 & $i3)); } } else { list($i9, $iA) = self::parseIpRange($i1); $iB = (float) sprintf('%u', ip2long($i9)); $iC = (float) sprintf('%u', ip2long($iA)); $i7 = (float) sprintf('%u', ip2long($i)); return (($i7 >= $iB) && ($i7 <= $iC)); } } public static function ipInRanges($i, $i1 = [], $i2 = true) { if (isset($i1[0])) { $i3 = []; foreach($i1 as $i4) { $i3[$i4['range']] = $i4['allow']; } } else { $i3 = $i1; } foreach($i3 as $i5 => $i6) { $i7 = self::ipInRange($i, $i5); if (!$i7) continue; return $i6; } return $i2; } }
 final class Tii_Math { public static function getSequenceId() { static $i = 0; return ++$i; } public static function getSystemBits() { static $i = NULL; if (isset($i)) return $i; return $i = (log(PHP_INT_MAX + 1, 2) + 1); } public static function getStatus($i, $i1, $i2 = 1) { return $i >> --$i1 & (1 << $i2) - 1; } public static function setStatus($i, $i1, $i2 = true, $i3 = 1) { if ($i1 <= 0 || $i3 <= 0 || (intval($i2) > (pow(2, $i3) - 1))) return false; $i2 = sprintf('%0' . $i3 . 'b', $i2); --$i1; $i &= ~((pow(2, $i3) - 1)<< $i1); for ($i4 = $i3 - 1; $i4 >= 0; $i4--) { if (isset($i2[$i4]) && $i2[$i4]) { $i |= (1<< $i1); } else { $i &= ~(1<<$i1); } ++$i1; } return $i; } public static function getFloatLength($i) { $i1 = 0; $i2 = explode ('.', $i); if (count($i2) > 1) { $i1 = strlen(end($i2)); } return $i1; } public static function pather(array &$i, array $i1, $i2, $i3, $i4, $i5 = true) { foreach($i1 as $i6) { $i[] = $i5 ? $i6[$i3] : $i6; if ($i6[$i3] == $i2) return true; if (is_array($i6[$i4]) && self::pather($i, $i6[$i4], $i2, $i3, $i4, $i5)) return true; array_pop($i); } return false; } public static function toGuidString($i, $i1 = 'md5') { if (is_object($i) && function_exists('spl_object_hash')) { return spl_object_hash($i); } elseif (is_resource($i)) { $i = get_resource_type($i) . strval($i); } else { $i = serialize($i); } return call_user_func($i1, $i); } public static function random($i = 6, $i1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz', $i2 = '') { mt_srand(); $i3 = ''; $i4 = (is_array($i1) ? count($i1) : strlen($i1)) - 1; $i5 = (is_array($i2) ? count($i2) : strlen($i2)) - 1; for ($i6 = 0; $i6 < $i; $i6++) { if ($i4 > 0) $i3 .= $i1[mt_rand(0, $i4)]; if (strlen($i3) === $i) break; if ($i5 > 0) $i3 .= $i2[mt_rand(0, $i5)]; if (strlen($i3) === $i) break; } return $i3; } public static function randomDigital($i = 6) { return self::random($i, '0123456789'); } public static function randomReadableString($i = 6) { return self::random($i, "bcdfghjklmnprstvwxyz", 'aeiou'); } public static function guid16() { return self::guid('0123456789abcdef'); } public static function mask($i, array $i1, $i2 = '*') { foreach($i1 as $i3) { $i{$i3} = $i2; } return $i; } public static function guid($i = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz') { return self::mask(self::random(32, $i), [8, 13, 18, 23], '-'); } public static function getScaleRandom(array $i, array $i1 = []) { $i2 = []; $i3 = 0; foreach($i as $i4 => $i5) { if (isset($i1[$i4])) { $i5 = $i5 * (1 + $i1[$i4]/100); } $i5 = strval($i5); $i6 = self::getFloatLength($i5); $i3 = $i3 > $i6 ? $i3 : $i6; $i2[$i5][] = $i4; } if ($i3) { foreach($i2 as $i4 => $i5) { $i2[strval($i4 * pow(10, $i3))] = $i5; unset($i2[$i4]); } } $i7 = 0; $i8 = []; foreach($i2 as $i4 => $i5) { $i7 += $i4 * count($i5); $i8[$i7] = $i5; } mt_srand(); $i9 = mt_rand(1, $i7); $iA = 0; foreach($i8 as $i4 => $i5) { if ($i9 > $iA && $i9 <= $i4) { return $i5[array_rand($i5)]; } else { $iA = $i4; } } } public static function hash($i, $i1 = [], $i2 = 32) { $i3 = []; is_array($i1) || $i1 = [$i1]; foreach($i1 as $i4) { for ($i5 = 0; $i5 < $i2; $i5++) { $i3[crc32($i4 . '#' . $i5)] = $i4; } } if (empty($i3)) return NULL; ksort($i3, SORT_REGULAR); $i6 = crc32($i); foreach ($i3 as $i7 => $i4) { if ($i7 > $i6) return $i4; } return array_pop($i3); } public static function decst($i) { $i1 = ''; while ($i != 0) { $i2 = $i % 62; if ($i2 >= 10 && $i2 < 36) { $i1 .= chr($i2 + 55); } elseif ($i2 >= 36 && $i2 < 62) { $i1 .= chr($i2 + 61); } else { $i1 .= $i2; } $i = intval($i / 62); } return strval(strrev($i1)); } public static function stdec($i) { $i1 = 0; $i2 = strlen($i); $i3 = 0; while($i2--) { $i4 = $i{$i3++}; $i5 = ord($i4); if ($i5 >= 48 && $i5 <= 57) { $i1 += $i4 * pow(62, $i2); } elseif ($i5 >= 65 && $i5 <= 90) { $i1+= ($i5 - 55) * pow(62, $i2); } else { $i1+= ($i5 - 61) * pow(62, $i2); } } return $i1; } public static function uniqId($i = '') { list($i1, $i2) = explode(" ", microtime()); return sprintf("%s%05s%04s", $i, self::decst($i2), self::decst($i1*10000000)); } public static function hashStr($i, $i1 = true) { $i2 = sprintf("%u", crc32($i)); return $i1 ? sprintf('%06s', self::decst($i2)) : $i2; } public static function hashArr() { $i = func_get_args(); sort($i, SORT_STRING); return sha1(implode($i)); } }
 final class Tii_Logger { public static $print = false; public static $print_backtrace_priority = Tii_Logger_Constant::EMERG; public static function __callStatic($i, $i1) { static $i2; if (!$i2) { $i2 = Tii::object(Tii::get('tii.logger.handler', ['Tii_Logger_File'])); $i3 = Tii::get('tii.logger.priority', false); if ($i3) $i2->setPriority($i3); } return call_user_func_array([$i2, $i], $i1); } }
 class Tii_Logger_File extends Tii_Logger_Abstract { private $path; private $format; public function __construct($path = NULL, $format = 'Ymd') { parent::__construct(); $this->path = $path ?: Tii_Filesystem::getTempDir(); Tii_Filesystem::mkdir($this->path); $this->format = $format; } public function doLog($i, $i1 = Tii_Logger_Constant::ERR, $i2 = NULL) { return file_put_contents( Tii_Filesystem::concat($this->path, Tii_Time::format($this->format) . '.log'), sprintf( "%s\t%s\t%s\t%s\n", Tii_Time::format('H:i:s'), $this->getPriorityName($i1), strval($i), json_encode($i2) ), FILE_APPEND ); } }
 class Tii_Logger_Dao extends Tii_Logger_Abstract { private $dao; private $table; private $fields = [ 'id' => 'id', 'priority' => 'priority', 'message' => 'message', 'extras' => 'extras', 'gmt_created' => 'gmt_created', ]; public function __construct($dao = NULL, $table = 'logger', $fields = []) { parent::__construct(); $this->dao = ($dao instanceof Tii_Dao) ? $dao : Tii::object('Tii_Dao', $dao); $this->table = $table; $this->fields = array_merge($this->fields, $fields); } public function doLog($i, $i1 = Tii_Logger_Constant::ERR, $i2 = NULL) { return $this->dao->insert($this->table, [ $this->fields['priority'] => $i1, $this->fields['message'] => strval($i), $this->fields['extras'] => json_encode($i2), $this->fields['gmt_created'] => Tii_Time::format(), ]); } }
 abstract class Tii_Logger_Constant { const EMERG = 0; const ALERT = 1; const CRIT = 2; const ERR = 3; const WARN = 4; const NOTICE = 5; const INFO = 6; const DEBUG = 7; const ALL = 8; }
 class Tii_Application_SessionHandler_Cache implements SessionHandlerInterface { private $maxlifetime = 0; private $cache; private $prefix = 'tii.session.'; public function __construct() { $this->cache = Tii::object('Tii_Cache'); $this->maxlifetime = ini_get('session.gc_maxlifetime'); } public function open($i, $i1) { return true; } public function close() { return true; } public function read($i) { return $this->cache->get($this->prefix . $i); } public function write($i, $i1) { return $this->cache->set($this->prefix . $i, $i1, 0, $this->maxlifetime); } public function destroy($i) { return $this->cache->delete($this->prefix . $i); } public function gc($maxlifetime) { return true; } }
 final class Tii_Http { public static function post($i, $i1 = '', array $i2 = [], array $i3 = [], $i4 = 'POST') { $i5 = self::parseUrl($i); if (is_array($i1)) { $i6 = call_user_func_array(['self', 'preparePostBody'], $i1); $i2 = array_merge($i2, $i6['headers']); $i1 = $i6['data']; } return self::responser($i, $i2, $i5, $i3, $i4, $i1); } public static function get($i, array $i1 = [], array $i2 = [], $i3 = 'GET') { $i4 = self::parseUrl($i); return self::responser($i, $i1, $i4, $i2, $i3); } protected static function response($i, array $i1) { $i2 = new stdClass(); $i2->state = 0; $i2->data = NULL; $i2->headers = []; $i2->runtime = ['timestamp' => [], 'time_consuming' => ['trace' => [], 'total' => 0]]; $i2->handler = NULL; $i2->runtime['timestamp']['start'] = microtime(true); $i3 = parse_url($i1['remote_socket']); if (function_exists('stream_socket_client')) { isset($i1['flags']) || $i1['flags'] = STREAM_CLIENT_CONNECT | STREAM_CLIENT_PERSISTENT; if (isset($i1['contexts'][$i1['parseUrl']['host']])) { $i1['context'] = $i1['contexts'][$i1['parseUrl']['host']]; } isset($i1['context']) || $i1['context'] = stream_context_create(); $i4 = @stream_socket_client( $i1['remote_socket'], $i5, $i6, $i1['timeout'], $i1['flags'], $i1['context'] ); $i2->handler = '@stream_socket_client'; } else { $i7 = sprintf('%s://%s', $i3['scheme'], $i3['host']); if (function_exists('fsockopen')) { $i4 = @fsockopen($i7, $i3['port'], $i5, $i6, $i1['timeout']); $i2->handler = '@fsockopen'; } elseif (function_exists('pfsockopen')) { $i4 = @pfsockopen($i7, $i3['port'], $i5, $i6, $i1['timeout']); $i2->handler = '@pfsockopen'; } else { throw new Tii_Exception("stream_socket_client,*fsockopen function were forbidden"); } } if (!is_resource($i4)) { throw new Exception(Tii::lang($i6), $i5); } $i2->options = $i1; $i2->runtime['timestamp']['connection'] = microtime(true); $i2->runtime['time_consuming']['trace']['connection'] = self::timeConsumption( $i2->runtime['timestamp']['connection'], $i2->runtime['timestamp']['start'] ); list($i8, $i9) = explode('.', $i2->options['timeout'] . '.'); stream_set_timeout($i4, intval($i8), intval($i9)); if ($i1['is_proxy_mode'] && $i1['parseUrl']['scheme'] == 'https') { if (!fwrite($i4, self::streamBuilder( "CONNECT {$i1['parseUrl']['host']}:{$i1['parseUrl']['port']} {$i1['protocol']}", ['Host' => $i3['host']] ))) { @fclose($i4); throw new Tii_Exception("write https connect error"); } $iA = trim(fgets($i4)); if (!$iA) { @fclose($i4); throw new Tii_Exception("response https connect header error"); } list($iB, $iC, $iD) = explode(' ', $iA, 3); if ($iC != 200) { @fclose($i4); throw new Tii_Exception("connection unestablished"); } stream_socket_enable_crypto($i4, true, STREAM_CRYPTO_METHOD_TLS_CLIENT); $i2->proxy = [ 'proto' => $iB, 'state' => $iC, 'message' => $iD, 'headers' => [], ]; while (($iA = trim(fgets($i4))) != '') { if (strpos($iA, ':') === false) continue; list ($iE, $iF) = explode(':', $iA, 2); $iE = str_replace(' ', '-', ucwords(str_replace('-', ' ', strtolower($iE)))); if (isset($i2->proxy['headers'][$iE])) { $i2->proxy['headers'][$iE] = $i2->proxy['headers'][$iE] . '; ' . trim($iF); } else { $i2->proxy['headers'][$iE] = trim($iF); } } } @fwrite($i4, $i); $iG = stream_get_meta_data($i4); if ($iG['timed_out']) { @fclose($i4); throw new Tii_Exception("connection timed out, defined %s, cost %s (unit:second)", $i2->options['timeout'], $i2->runtime['connection'] ); } $i2->runtime['timestamp']['request'] = microtime(true); $i2->runtime['time_consuming']['trace']['request'] = self::timeConsumption($i2->runtime['timestamp']['request'], $i2->runtime['timestamp']['connection']); $iA = trim(fgets($i4)); if (!$iA) { @fclose($i4); throw new Tii_Exception("response header error"); } list($iB, $iC, $iD) = explode(' ', $iA, 3); while (($iA = trim(fgets($i4))) != '') { if (strpos($iA, ':') === false) continue; list ($iE, $iF) = explode(':', $iA, 2); $iE = str_replace(' ', '-', ucwords(str_replace('-', ' ', strtolower($iE)))); if (isset($i2->headers[$iE])) { $i2->headers[$iE] = $i2->headers[$iE] . '; ' . trim($iF); } else { $i2->headers[$iE] = trim($iF); } } if (array_key_exists('Transfer-Encoding', $i2->headers)) { $iH = self::getSocketBodyByTransferEncoding($i4, $i2->headers['Transfer-Encoding']); } else { $iH = self::getSocketBodyByNormal($i4); } if (array_key_exists('Content-Encoding', $i2->headers)) { self::contentDecoding($iH, $i2->headers['Content-Encoding']); } $i2->runtime['timestamp']['response'] = microtime(true); $i2->runtime['time_consuming']['trace']['response'] = self::timeConsumption($i2->runtime['timestamp']['response'], $i2->runtime['timestamp']['request']); @fclose($i4); $i2->proto = $iB; $i2->state = intval($iC); $i2->message = $iD; $i2->data = $iH; $i2->runtime['timestamp']['finish'] = microtime(true); $i2->runtime['time_consuming']['trace']['finish'] = self::timeConsumption($i2->runtime['timestamp']['finish'], $i2->runtime['timestamp']['response']); $i2->runtime['time_consuming']['total'] = self::timeConsumption($i2->runtime['timestamp']['finish'], $i2->runtime['timestamp']['start']); return $i2; } protected static function responser($i, $i1, $i2, $i3, $i4, $i5 = '') { array_key_exists('Host', $i1) || $i1['Host'] = $i2['host']; $i3 = array_merge([ 'url' => $i, 'method' => $i4, 'protocol' => 'HTTP/1.1', 'headers' => $i1, 'parseUrl' => $i2, 'is_proxy_mode' => false, ], $i3); isset($i3['timeout']) || $i3['timeout'] = ini_get("default_socket_timeout"); if (empty($i3['remote_socket'])) { switch($i3['parseUrl']['scheme']) { case 'https': $i3['remote_socket'] = 'ssl'; break; default: $i3['remote_socket'] = 'tcp'; break; } $i3['remote_socket'] .= sprintf("://%s:%d", $i3['parseUrl']['host'], $i3['parseUrl']['port']); } $i3 = Tii_Event::filter('tii.http.options', $i3); $i6 = $i3['is_proxy_mode'] ? $i : $i2['query_string']; return self::response(self::streamBuilder("{$i3['method']} $i6 {$i3['protocol']}", $i1, $i5), $i3); } protected static function timeConsumption($i, $i1, $i2 = 4) { return number_format($i - $i1, $i2); } protected static function getSocketBodyByTransferEncoding(&$i, $i1) { switch (strtolower($i1)) { case 'chunked' : return self::getSocketBodyByChunked($i); default: return self::getSocketBodyByNormal($i); } } protected static function contentDecoding(&$i, $i1) { switch (strtolower($i1)) { case 'gzip' : $i = self::gzdecode($i); break; default: break; } } protected static function gzdecode(&$i) { if (function_exists('gzdecode')) return gzdecode($i); return file_get_contents('compress.zlib://data:who/cares;base64,'. base64_encode($i)); } protected static function getSocketBodyByChunked(&$i) { $i1 = ''; while(!feof($i) && ($i2 = (int)hexdec(fgets($i)))) { while ($i2 > 0) { $i3 = fread($i, $i2); $i1 .= $i3; $i2 -= strlen($i3); } fread($i, 2); } return $i1; } protected static function getSocketBodyByNormal(&$i) { $i1 = false; $i2 = 0; $i3 = ''; while(!feof($i) && !$i1) { $i4 = fread($i, ($i2 == 0 || $i2 > 8192 ? 8192 : $i2)); $i3 .= $i4; if ($i2) { $i2 -= strlen($i4); $i1 = $i2 <= 0; } } return $i3; } public static function streamBuilder($i, $i1 = [], $i2 = '') { $i1 = array_merge([ 'User-Agent' => 'Tii/' . Tii_Version::VERSION, 'Content-Length' => strlen($i2), 'Connection' => 'close', ], $i1); $i3 = []; $i3[] = $i; foreach ($i1 as $i4 => $i5) { $i3[] = sprintf("%s: %s", $i4, $i5); } return implode("\r\n", $i3)."\r\n\r\n".$i2; } public static function parseUrl($i) { $i1 = parse_url($i); if (!$i1 || !is_array($i1)) { throw new Tii_Exception("parse URL `%s' error", $i); } array_key_exists('port', $i1) || $i1['port'] = ($i1['scheme'] === 'https') ? 443 : 80; $i2 = array_key_exists('path', $i1) ? $i1['path'] : '/'; array_key_exists('query', $i1) && $i2 .= '?' . $i1['query']; array_key_exists('fragment', $i1) && $i2 .= '#' . $i1['fragment']; $i1['query_string'] = $i2; return $i1; } public static function preparePostBody(array $i, array $i1 = []) { if (count($i) == 0 && count($i1) == 0) return ['data' => '', 'headers' => []]; $i2 = []; if (count($i1) > 0) { $i3 = "multipart/form-data"; } else { $i3 = "application/x-www-form-urlencoded"; } switch ($i3) { case "application/x-www-form-urlencoded": reset($i); $i4 = []; while(list($i5, $i6) = each($i)) { if (is_array($i6) || is_object($i6)) { while (list($i7, $i8) = each($i6)) { $i4[] = urlencode($i5)."[$i7]=".urlencode($i8); } } else { $i4[] = urlencode($i5)."=".urlencode($i6); } } $i2['Content-Type'] = $i3; $i4 = implode('&', $i4); break; case "multipart/form-data": $i9 = "Boundary".md5(uniqid(microtime())); reset($i); $i4 = ''; while(list($i5,$i6) = each($i)) { if (is_array($i6) || is_object($i6)) { while (list($i7, $i8) = each($i6)) { $i4 .= "--".$i9."\r\n"; $i4 .= "Content-Disposition: form-data; name=\"$i5\[$i7\]\"\r\n"; $i4 .= "Content-Type: text/plain; charset=utf-8\r\n\r\n"; $i4 .= "$i8\r\n"; } } else { $i4 .= "--".$i9."\r\n"; $i4 .= "Content-Disposition: form-data; name=\"$i5\"\r\n"; $i4 .= "Content-Type: text/plain; charset=utf-8\r\n\r\n"; $i4 .= "$i6\r\n"; } } reset($i1); while (list($iA, $iB) = each($i1)) { settype($iB, "array"); while (list(, $iC) = each($iB)) { if (!is_readable($iC)) continue; $iD = file_get_contents($iC); $iE = pathinfo($iC); $iF = array_key_exists("basename", $iE) ? $iE["basename"] : basename($iC); $iG = array_key_exists("extension", $iE) ? $iE["extension"] : substr(strrchr($iF, "."), 1); $i4 .= "--".$i9."\r\n"; $i4 .= "Content-Disposition: form-data; name=\"$iA\"; filename=\"$iF\"\r\n"; $iH = self::getMimeType($iG); $i4 .= "Content-Type: $iH; Content-Transfer-Encoding: binary\r\n\r\n"; $i4 .= "$iD\r\n"; } } $i4 .= "--".$i9."--\r\n"; $i2['Content-Type'] = "$i3; boundary=".$i9; break; } return ['data' => $i4, 'headers' => $i2]; } public static function parser($i, $i1 = '127.0.0.1', $i2 = 0) { $i3 = ''; $i4 = $i5 = $i6 = $i7 = $i8 = []; $i9 = array_merge($_SERVER, [ 'QUERY_STRING' => '', 'REQUEST_METHOD' => 'GET', 'REQUEST_URI' => '/', 'REQUEST_TIME_FLOAT' => Tii_Time::micro(), 'REQUEST_TIME' => Tii_Time::now(), 'SERVER_PROTOCOL' => 'HTTP/1.1', 'SERVER_SOFTWARE' => 'Tii/'.Tii_Version::VERSION, 'SERVER_NAME' => gethostname(), 'HTTP_HOST' => '', 'HTTP_USER_AGENT' => '', 'HTTP_ACCEPT' => '', 'HTTP_ACCEPT_LANGUAGE' => '', 'HTTP_ACCEPT_ENCODING' => '', 'HTTP_COOKIE' => '', 'HTTP_CONNECTION' => '', 'REMOTE_ADDR' => $i1, 'REMOTE_PORT' => $i2, ]); list($iA, $iB) = explode("\r\n\r\n", $i, 2); $iC = explode("\r\n", $iA); list($iD, $iE, $iF) = explode(' ', array_shift($iC)); if ($iD) $i9['REQUEST_METHOD'] = $iD; if ($iE) $i9['REQUEST_URI'] = $iE; if ($iF) $i9['SERVER_PROTOCOL'] = $iF; $iG = ''; foreach ($iC as $iH) { if (empty($iH)) continue; list($iI, $iJ) = explode(':', $iH, 2); $iI = str_replace('-', '_', strtoupper($iI)); $iJ = trim($iJ); $i9['HTTP_' . $iI] = $iJ; switch($iI) { case 'HOST': $iK = explode(':', $iJ); $i9['SERVER_ADDR'] = $iK[0]; if (isset($iK[1])) $i9['SERVER_PORT'] = $iK[1]; break; case 'COOKIE': $i9['HTTP_COOKIE'] = $iJ; $i6 = self::parseCookie($iJ); break; case 'CONTENT_TYPE': if (!preg_match('/boundary="?(\S+)"?/', $iJ, $iL)) { $i9['CONTENT_TYPE'] = $iJ; } else { $i9['CONTENT_TYPE'] = 'multipart/form-data'; $iG = '--'.$iL[1]; } break; } } if ($i9['REQUEST_METHOD'] === 'POST') { $iM = Tii_Filesystem::bytes(ini_get('upload_max_filesize')); if (isset($i9['CONTENT_TYPE']) && $i9['CONTENT_TYPE'] === 'multipart/form-data') { $iB = substr($iB, 0, strlen($iB) - (strlen($iG) + 4)); $iN = explode($iG."\r\n", $iB); if ($iN[0] === '') { unset($iN[0]); } foreach($iN as $iO) { list($iP, $iQ) = explode("\r\n\r\n", $iO, 2); $iQ = substr($iQ, 0, -2); foreach (explode("\r\n", $iP) as $iR) { list($iS, $iT) = explode(": ", $iR); $iS = strtolower($iS); switch ($iS) { case "content-disposition": if (preg_match('/name="([^"]*)"; filename="([^"]*)"$/', $iT, $iL)) { $iU = [ 'name' => $iL[2], 'type' => self::getMimeType(Tii_Filesystem::getFilenameExt($iL[2])), 'data' => $iQ, 'tmp_name' => Tii_Filesystem::tempnam(), 'size' => strlen($iQ), 'error' => UPLOAD_ERR_OK, ]; if ($iU['size'] <= 0) { $iU['error'] = UPLOAD_ERR_NO_FILE; } else if ($iU['size'] > $iM) { $iU['error'] = UPLOAD_ERR_INI_SIZE; } else { if (!file_put_contents($iU['tmp_name'], $iQ)) { $iU['error'] = UPLOAD_ERR_CANT_WRITE; } } $i8[$iL[1]] = $iU; continue; } else { if(preg_match('/name="(.*?)"$/', $iT, $iL)) { $i5[$iL[1]] = $iQ; } } break; } } } } else { parse_str($iB, $i5); $i3 = $iB; } } $i9['QUERY_STRING'] = parse_url($i9['REQUEST_URI'], PHP_URL_QUERY); if($i9['QUERY_STRING']) { parse_str($i9['QUERY_STRING'], $i4); } else { $i9['QUERY_STRING'] = ''; } $i7 = array_merge($i4, $i5, $i6); return [$i9, $i4, $i5, $i6, $i7, $i8, $i3]; } public static function parseCookie($i) { $i1 = []; foreach(explode("; ", $i) as $i2) { list($i3, $i4) = explode("=", $i2, 2); $i1[trim($i3)] = trim($i4); } return $i1; } public static function tidyCookie() { $i = implode('; ', func_get_args()); $i1 = []; foreach(self::parseCookie($i) as $i2 => $i3) { if (empty($i2)) continue; if (preg_match('/^(domain|httponly|path|secure|expires)$/i', $i2)) continue; $i1[] = sprintf("%s=%s", $i2, $i3); } return implode("; ", $i1); } public static function urlAppend($i, $i1 = NULL) { if (empty($i1)) return $i; return $i . ((($i2 = strpos($i, '?')) === false) ? '?' : ($i2 < (strlen($i) - 1) ? '&' : '')) . (is_array($i1) ? http_build_query($i1) : $i1); } public static function concat() { $i = []; foreach(func_get_args() as $i1) { empty($i1) || $i[] = rtrim($i1, '\\/'); } return implode('/', $i); } public static function getMimeType($i) { switch (strtolower($i)) { case 'html': case 'htm': case 'shtml': return 'text/html'; case 'css': return 'text/css'; case 'xml': return 'text/xml'; case 'gif': return 'image/gif'; case 'jpeg': case 'jpg': return 'image/jpeg'; case 'js': return 'application/x-javascript'; case 'json': return 'application/json'; case 'atom': return 'application/atom+xml'; case 'rss': return 'application/rss+xml'; case 'mml': return 'text/mathml'; case 'serialize': case 'txt': return 'text/plain'; case 'jad': return 'text/vnd.sun.j2me.app-descriptor'; case 'wml': return 'text/vnd.wap.wml'; case 'htc': return 'text/x-component'; case 'png': return 'image/png'; case 'tif': case 'tiff': return 'image/tiff'; case 'wbmp': return 'image/vnd.wap.wbmp'; case 'ico': return 'image/x-icon'; case 'jng': return 'image/x-jng'; case 'bmp': return 'image/x-ms-bmp'; case 'svg': return 'image/svg+xml'; case 'jar': case 'war': case 'ear': return 'application/java-archive'; case 'hqx': return 'application/mac-binhex40'; case 'doc': return 'application/msword'; case 'pdf': return 'application/pdf'; case 'ps': case 'eps': case 'ai': return 'application/postscript'; case 'rtf': return 'application/rtf'; case 'xls': return 'application/vnd.ms-excel'; case 'ppt': return 'application/vnd.ms-powerpoint'; case 'wmlc': return 'application/vnd.wap.wmlc'; case 'kml': return 'application/vnd.google-earth.kml+xml'; case 'kmz': return 'application/vnd.google-earth.kmz'; case '7z': return 'application/x-7z-compressed'; case 'cco': return 'application/x-cocoa'; case 'jardiff': return 'application/x-java-archive-diff'; case 'jnlp': return 'application/x-java-jnlp-file'; case 'run': return 'application/x-makeself'; case 'pl': case 'pm': return 'application/x-perl'; case 'prc': case 'pdb': return 'application/x-pilot'; case 'rar': return 'application/x-rar-compressed'; case 'rpm': return 'application/x-redhat-package-manager'; case 'sea': return 'application/x-sea'; case 'swf': return 'application/x-shockwave-flash'; case 'sit': return 'application/x-stuffit'; case 'tcl': case 'tk': return 'application/x-tcl'; case 'der': case 'pem': case 'crt': return 'application/x-x509-ca-cert'; case 'xpi': return 'application/x-xpinstall'; case 'xhtml': return 'application/xhtml+xml'; case 'zip': return 'application/zip'; case 'bin': case 'exe': case 'dll': case 'deb': case 'dmg': case 'eot': case 'iso': case 'img': case 'msi': case 'msp': case 'msm': return 'application/octet-stream'; case 'mid': case 'midi': case 'kar': return 'audio/midi'; case 'mp3': return 'audio/mpeg'; case 'ogg': return 'audio/ogg'; case 'ra': return 'audio/x-realaudio'; case '3gpp': case '3gp': return 'video/3gpp'; case 'mpeg': case 'mpg': return 'video/mpeg'; case 'mov': return 'video/quicktime'; case 'flv': return 'video/x-flv'; case 'mng': return 'video/x-mng'; case 'asx': case 'asf': return 'video/x-ms-asf'; case 'wmv': return 'video/x-ms-wmv'; case 'avi': return 'video/x-msvideo'; default: return 'text/plain'; } } public static function getHttpStatus($i = 200) { static $i1 = [ 100 => 'Continue', 101 => 'Switching Protocols', 200 => 'OK', 201 => 'Created', 202 => 'Accepted', 203 => 'Non-Authoritative Information', 204 => 'No Content', 205 => 'Reset Content', 206 => 'Partial Content', 300 => 'Multiple Choices', 301 => 'Moved Permanently', 302 => 'Moved Temporarily ', 303 => 'See Other', 304 => 'Not Modified', 305 => 'Use Proxy', 307 => 'Temporary Redirect', 400 => 'Bad Request', 401 => 'Unauthorized', 402 => 'Payment Required', 403 => 'Forbidden', 404 => 'Not Found', 405 => 'Method Not Allowed', 406 => 'Not Acceptable', 407 => 'Proxy Authentication Required', 408 => 'Request Timeout', 409 => 'Conflict', 410 => 'Gone', 411 => 'Length Required', 412 => 'Precondition Failed', 413 => 'Request Entity Too Large', 414 => 'Request-URI Too Long', 415 => 'Unsupported Media Type', 416 => 'Requested Range Not Satisfiable', 417 => 'Expectation Failed', 422 => 'Unprocessable Entity', 423 => 'Locked', 424 => 'Failed Dependency', 500 => 'Internal Server Error', 501 => 'Not Implemented', 502 => 'Bad Gateway', 503 => 'Service Unavailable', 504 => 'Gateway Timeout', 505 => 'HTTP Version Not Supported', 507 => 'Insufficient Storage', 509 => 'Bandwidth Limit Exceeded' ]; return Tii::valueInArray($i1, $i); } }
 final class Tii_Filesystem { const FOLDER = 1; const FILE = 2; const BOTH = 3; public static $units = ['B', 'Kb', 'Mb', 'Gb', 'Tb', 'PB', 'EB', 'ZB', 'YB']; public static function getTempDir() { static $i; $i || $i = self::concat(Tii::get('tii.temp_dir', sys_get_temp_dir()), PHP_SAPI); return $i; } public static function getDataDir() { static $i; $i || $i = self::concat(Tii::get('tii.data_dir', self::getTempDir()), PHP_SAPI); return $i; } public static function concat() { $i = []; foreach(func_get_args() as $i1) { empty($i1) || $i[] = rtrim($i1, '\\/'); } return implode(DIRECTORY_SEPARATOR, $i); } public static function explode($i) { return explode(DIRECTORY_SEPARATOR, $i); } public static function getFilenameExt($i) { return strtolower(substr(strrchr($i, "."), 1)); } public static function getBasenameWithoutExt($i) { return preg_replace('|\.([^.]*$)|', '', basename($i)); } public static function getRelativePathFiles($i, array $i1 = [], $i2 = true, $i3 = self::FILE) { $i4 = strlen(realpath($i)); return array_map(function($i5) use ($i4) {return substr($i5, $i4+1);}, self::getFiles($i, $i1, $i2, $i3)); } public static function getRelativePathFolders($i, $i1 = true) { return self::getRelativePathFiles($i, [], $i1, self::FOLDER); } public static function getFolders($i, $i1 = true) { return self::getFiles($i, [], $i1, self::FOLDER); } public static function getFiles($i, array $i1 = [], $i2 = true, $i3 = self::FILE) { $i4 = []; if (is_dir($i) && $i5 = opendir($i)) { while (false !== ($i6 = readdir($i5))) { if ($i6 != "." && $i6 != "..") { if (is_dir($i7 = self::concat($i, $i6))) { Tii_Math::getStatus($i3, 1) && $i4[] = realpath($i7); if (!$i2) continue; foreach(self::getFiles(self::concat($i, $i6), $i1, $i2, $i3) as $i8) { $i4[] = realpath($i8); } } elseif(Tii_Math::getStatus($i3, 2)) { if (empty($i1) || in_array(self::getFilenameExt($i6), $i1)) { $i4[] = realpath(self::concat($i, $i6)); } } } } } return $i4; } public static function isWritable($i) { if (DIRECTORY_SEPARATOR == '/' && @ini_get("safe_mode") == false) { return is_writable($i); } if (is_dir($i)) { $i = rtrim($i, '/').'/'.md5(mt_rand(1,100).mt_rand(1,100)); if (($i1 = @fopen($i, 'ab')) === false) { return false; } fclose($i1); @chmod($i, 0777); @unlink($i); return true; } elseif ( ! is_file($i) OR ($i1 = @fopen($i, 'ab')) === false) { return false; } fclose($i1); return true; } public static function mkdir($i, $i1 = 0777) { is_dir($i) || clearstatcache(); return is_dir($i) ? false : mkdir($i, $i1, true); } public static function rmdir($i, $i1 = false) { is_dir($i) || clearstatcache(); if (!is_dir($i)) return false; if ($i1) { $i2 = opendir($i); while(false !== ($i3 = readdir($i2))) { if (($i3 != '.') && ($i3 != '..')) { $i4 = $i . '/' . $i3; if (is_dir($i4)) { self::rmdir($i4, $i1); } else { unlink($i4); } } } closedir($i2); } return rmdir($i); } public static function unlink($i) { is_file($i) || clearstatcache(); return is_file($i) && unlink($i); } public static function touch($i, $i1 = null, $i2 = null) { return touch($i, $i1, $i2); } public static function copy($i, $i1) { return copy($i, $i1); } public static function tempnam($i = 'tii.', $i1 = '') { return tempnam(self::getTempDir(), $i) . $i1; } public static function tempfile() { $i = func_get_args(); $i1 = array_shift($i); array_unshift($i, self::getTempDir()); $i[] = $i1; $i1 = call_user_func_array('self::concat', $i); self::mkdir(dirname($i1)); return $i1; } public static function hashfile($i, $i1 = 'tii', $i2 = '', $i3 = NULL) { static $i4 = []; if (!isset($i4[$i][$i1][$i2][$i3])) { $i5 = md5($i).md5(strrev($i)); $i4[$i][$i1][$i2][$i3] = self::concat( $i3 ?: self::getTempDir(), $i1, substr($i5, 0, 3), substr($i5, 4, 3), $i5 ) . $i2; self::mkdir(dirname($i4[$i][$i1][$i2][$i3])); } return $i4[$i][$i1][$i2][$i3]; } public static function locker($i, $i1 = NULL, $i2 = NULL) { $i3 = fopen(self::hashfile($i, 'filesystem/mutex'), 'w+'); if (flock($i3, LOCK_EX | LOCK_NB)) { if (is_callable($i1)) call_user_func($i1); flock($i3, LOCK_UN); } else { if (is_callable($i2)) call_user_func($i2); } fclose($i3); } public static function cached($i, $i1 = 0, $i2 = NULL, array $i3 = [], $i4 = true) { try { return call_user_func_array('self::_cached', func_get_args()); } catch (Exception $i5) { Tii_Logger::warn("file cache `$i' exception:". $i5->getMessage()); return Tii::call($i2, $i3); } } private static function _cached($i, $i1 = 0, $i2 = NULL, array $i3 = [], $i4 = true) { $i5 = self::hashfile($i, 'filesystem/cached'); if ($i1 < 0) { $i6 = Tii::call($i2, $i3); self::unlink($i5); return $i6; } $i7 = is_file($i5) && (($i8 = intval(filemtime($i5))) > 0); if ($i7 && (!$i1 || ((time() - $i8) <= $i1))) { Tii_Logger::debug("got cache: `$i' via file: `$i5'"); return unserialize(file_get_contents($i5)); } $i9 = NULL; self::locker($i, function() use (&$i9, $i5, $i2, $i3){ ignore_user_abort(true); $i9 = Tii::call($i2, $i3); if (!is_null($i9)) { $i9 = serialize($i9); file_put_contents($i5, $i9, LOCK_EX); } ignore_user_abort(false); }, function() use (&$i9, $i5, $i1) { usleep(round(rand(0, 100) * 1000)); $i7 = (($i8 = intval(filemtime($i5))) > 0); if ($i7 && (!$i1 || ((time() - $i8) <= $i1))) { $i9 = file_get_contents($i5); } }); if ( is_null($i9) && $i4 && $i7 ) { Tii_Logger::warn("got expired cache: `$i' via file: `$i5'"); $i9 = file_get_contents($i5); } if ($i9) { return unserialize($i9); } else { return NULL; } } public static function format($i, $i1 = '%.2f%s', $i2 = 3, $i3 = 1024) { for ($i4 = 0; $i > $i3; $i4++) { $i /= $i3; } if (0 === $i4) { $i1 = preg_replace('/(%.[\d]+f)/', '%d', $i1); } return sprintf($i1, round($i, $i2), self::$units[$i4]); } public static function bytes($i, $i1 = 1024) { $i = trim(str_replace('B', '', strtoupper($i))); if (!is_numeric($i)) { $i2 = array_search(substr($i, -1), array_map(function($i3){return $i3{0};}, self::$units)); $i2 || $i2 = 0; $i *= pow($i1, $i2); } return intval($i); } }
 final class Tii_Application_Session { private static $started = false; public static function isStarted() { return self::$started; } public static function name($i = NULL) { return session_name(self::$started ? NULL: $i); } public static function start($i = NULL) { if ($i) { $i = Tii::object(func_get_args()); if ($i instanceof SessionHandlerInterface){ session_set_save_handler($i, true); } else { throw new Tii_Application_Exception("invalid session save handler"); } } self::$started = session_start(); } }
 class Tii_Application_Processor_Mock extends Tii_Application_Processor_Abstract { private $ip; protected function doBusyError($i, $i1) { sleep(1); } public function init() { $this->assignAll(NULL); $this->setPairs(NULL); } public function assign($i, $i1 = NULL) { return $this->setPair($i, $i1, 'result'); } public function assignAll($i) { return $this->setPairs($i, 'result'); } public function get($i, $i1 = NULL) { return $this->getPair($i, $i1, 'result'); } public function getResult($i = []) { return $this->getPairs($i, 'result'); } public function getResponse() {} public function setIp($ip) { $this->ip = $ip; } public function getIp() { return $this->ip; } public function getRequests() { return $this->getPairs(); } public function getRequest($i, $i1 = NULL) { return $this->getPair($i, $i1); } public function viewCached() {} public function over() {} }
 final class Tii_DocCommentParser { private $_shortDesc; private $_longDesc; private $_parameters = []; public function __construct($i) { if (!preg_match('|^/\*\*(.*)\*/|s', $i, $i1)) { return false; } $i1 = trim($i1[1]); if (preg_match_all('|^\s*\*(.*)|m', $i1, $i2) === false) { return false; } $i2 = explode("\n", trim(implode("\n", array_map(function($i3){return trim($i3);}, $i2[1])))); $i4 = []; for($i5 = 0, $i6 = count($i2); $i5 < $i6; $i5++) { $i7 = $i2[$i5]; if (strpos($i7, '@') === 0) { $i8 = substr($i7, 1, strpos($i7, ' ') - 1); $i9 = substr($i7, strlen($i8) + 2); if (preg_match('|(.*)<<<(\w+)$|', $i9, $iA)) { $i9 = []; $i9[] = $iA[1]; do { if ($iA[2].';' == $i2[++$i5]) break; else $i9[] = $i2[$i5]; } while($i5 < $i6); $i9 = implode("\n", $i9); } if (isset($this->_parameters[$i8])) { $this->_parameters[$i8][] = $i9; } else { $this->_parameters[$i8] = [$i9]; } } else { if (isset($this->_shortDesc)) { $i4[] = $i7; } else { $this->_shortDesc = $i7; } } } $this->_longDesc = implode("\n", $i4); return true; } public function shortDesc() { return $this->_shortDesc; } public function desc() { return $this->_longDesc; } public function get() { return [ 'shortDesc' => $this->shortDesc(), 'desc' => $this->desc(), 'parameters' => $this->_parameters, ]; } public function __get($i) { return Tii::valueInArray($this->_parameters, $i); } public function __call($i, $i1) { preg_match('/(is|int|float|get)(.*)/i', $i, $i2); if ($i2) { $i3 = lcfirst($i2[2]); $i4 = isset($this->_parameters[$i3][0]) ? $this->_parameters[$i3][0] : (isset($i1[0]) ? $i1[0] : NULL); switch($i2[1]) { case 'is': return (bool) $i4; case 'int': return intval($i4); case 'float': return floatval($i4); case 'get': default: return $i4; } } } }
 final class Tii_Delegate { private $_; public function __construct($i) { $i1 = new ReflectionClass($i); $i2 = []; foreach($i1->getMethods() as $i3) { $i4 = new Tii_DocCommentParser($i3->getDocComment()); if (!is_null($i4->cacheMode)) { $i2[$i3->getName()]['cache'] = (object)[ 'expired' => $i4->intExpired(), 'cacheName' => $i4->getCacheName(), 'cacheMode' => $i4->getCacheMode(), 'useExpired' => $i4->isUseExpired(true), ]; } } $i5 = []; foreach($i1->getProperties() as $i6) { $i6->setAccessible(true); $i5[$i6->name] = $i6->getValue($i); } $this->_ = new stdClass(); $this->_->that = $i; $this->_->clazz = $i1; $this->_->namespace = Tii_Config::getIdentifier() . "." . $i1->getName(); $this->_->annotations = $i2; $this->_->properties = $i5; } public function __get($i) { try { return $this->_->clazz->getProperty($i); } catch(Exception $i1) { if (isset($this->_->annotations['__get']['cache'])) { return $this->_( $i, $this->_->annotations['__get']['cache'], function($i, $i2) {return $i2->{$i};}, [$i, $this->_->that] ); } else { return $this->_->that->{$i}; } } } public function __call($i, $i1) { if (isset($this->_->annotations[$i]['cache'])) { return $this->_( $i, $this->_->annotations[$i]['cache'], [$this->_->that, $i], $i1 ); } else if (isset($this->_->annotations['__call']['cache'])) { return $this->_( $i, $this->_->annotations['__call']['cache'], [$this->_->that, $i], $i1 ); } else { return call_user_func_array([$this->_->that, $i], $i1); } } private function _($i, $i1, $i2 = NULL, array $i3) { if (empty($i1->cacheName)) { $i4 = $i . (empty($i3) ? "" : "." . Tii_Math::toGuidString($i3)); } else { $i4 = Tii::render($i1->cacheName, array_merge($i3, $this->_->properties, ['__call' => $i])); } $i5 = $this->_->namespace . "." . $i4; switch($i1->cacheMode) { case 'buffer': array_unshift($i3, $i5, $i2); return call_user_func_array('Tii::buffer', $i3); case 'cache': return Tii::object("Tii_Cache")->cached($i5, $i1->expired, $i2, $i3); case 'file': default: return Tii_Filesystem::cached($i5, $i1->expired, $i2, $i3, $i1->useExpired); } } } 
 final class Tii_Dao { private $connection; public function __construct($i = NULL) { is_array($i) || $i = Tii::get("tii.database." . Tii::value($i, 'default')); $this->connection = new Tii_Dao_Connection($i); } public function getConnection() { return $this->connection->getConnection(); } public function getSchema() { return $this->connection->getSchema(); } public function getQueryHelper() { return new Tii_Dao_Common_QueryHelper($this->getConnection()); } public function __call($i, $i1) { if (is_callable([$this->getQueryHelper(), $i])) { return call_user_func_array([$this->getQueryHelper(), $i], $i1); } } }
 class Tii_Application_Processor_Http_Response { private $headers = []; public function __construct() { $this->setHeader('Tii-Version', Tii_Version::VERSION, true); } public function isResponsed() { return headers_sent(); } public function done() { if ($this->isResponsed()) { return false; } foreach ($this->getHeaders() as $i => $i1) { is_array($i1) || $i1 = [$i1]; foreach ($i1 as $i2) { header("$i: $i2", false); } } } public function getHeaders() { return $this->headers; } public function setHeaders($headers) { $this->headers = array_merge($this->headers, $headers); return $this; } public function setHeader($i, $i1 = NULL, $i2 = false) { if ($i2 && !Tii_Config::isDebugMode()) { return false; } if (is_null($i1)) { switch(strtoupper($i)) { case 'P3P': $i1 = 'CP="CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR"'; break; default: } } return $this->setHeaders([$i => $i1]); } public function setCookie() { $i = func_get_args(); $i[0] = str_replace('.', '_', $i[0]); if ($i[0]{0} === '_') $i[1] = Tii_Security_Encryption::encode($i[1]); return call_user_func_array('setcookie', $i); } public function setSession($i, $i1 = NULL) { if (!Tii_Application_Session::isStarted()) { throw new Tii_Application_Exception("session was not successfully started"); } if (is_null($i1)) { unset($_SESSION[$i]); return true; } $_SESSION[$i] = $i1; return true; } public function unsetSession() { if (!Tii_Application_Session::isStarted()) { throw new Tii_Application_Exception("session was not successfully started"); } $i = func_get_args(); foreach ($i as $i1) { unset($_SESSION[$i1]); } return true; } public function sendHttpStatus($i = 200, $print = false) { if ($i1 = Tii_Http::getHttpStatus($i)) { header('HTTP/1.1 ' . $i . ' ' . $i1); header('Status:' . $i . ' ' . $i1); if ($print) echo $i1; } } public function sendForceDownload($i, $i1 = 0, $i2 = 'application/octet-stream') { if ($i1 > 0) $this->setHeader('Content-length', $i1); $this->setHeader('Content-Type', $i2); $this->setHeader('Content-Disposition', 'attachment; filename="' . $i . '"'); } public function output($i, $i1 = 'html', $i2 = false) { switch ($i1) { case 'html' : $i = Tii_Security_Filter::htmlChars($i); break; case 'javascript' : $i = Tii_Security_Filter::jsChars($i); break; default: $i = Tii_Security_Filter::str($i); break; } if ($i2) return $i; return print $i; } public function i18n() { return $this->output(call_user_func_array([Tii_Application::getInstance(), 'lang'], func_get_args())); } public function link() { return $this->output(call_user_func_array([Tii_Application::getInstance(), 'url'], func_get_args())); } }
 class Tii_Application_Helper_Html extends Tii_Application_Abstract { public $baseUrl = ''; public $title = ''; public $bodyAttrs = []; public $metas = []; public $scripts = []; public function __construct() { $this->addMeta('generator', 'Tii/' . Tii_Version::VERSION); $this->baseUrl = Tii::get('tii.application.helper.html.base_url', ''); } public function dom() { return Tii::object('DOMDocument', '1.0', 'utf-8'); } public function setTitle($title) { $this->title = $title; return $this; } public function getTitle() { return $this->title; } public function title($i = '') { static $i1; if ($i1) return ''; $i1 = true; return $this->nodeBuilder('title', [], false, Tii_Event::filter( 'tii.application.helper.html.title', $this->title ?: $i )); } public function addMeta($i, $i1 = NULL) { if (is_array($i)) { foreach($i as $i2 => $i3) { $this->addMeta($i2, Tii::value($i3, $i1)); } } else { $this->metas[$i] = Tii::value($i1, ''); } return $this; } public function getMeta($i, $i1 = NULL) { return Tii::valueInArray($this->metas, $i, $i1); } public function setKeywords($i) { $this->addMeta('keywords', is_array($i) ? implode(',', $i) : $i); return $this; } public function getKeywords() { return $this->getMeta('keywords', ''); } public function setDescription($i) { $this->addMeta('description', $i); return $this; } public function getDescription() { return $this->getMeta('description', ''); } public function metas() { static $i; if ($i) return ''; $i = true; $i1 = []; foreach(Tii_Event::filter('tii.application.helper.html.metas', $this->metas) as $i2 => $i3) { $i1[] = $this->nodeBuilder('meta', [ 'name' => $i2, 'content' => $i3, ]); } return implode("\n", $i1); } public function setBodyAttr($i, $i1 = NULL) { if (is_array($i)) { foreach($i as $i2 => $i3) { $this->setBodyAttr($i2, Tii::value($i3, $i1)); } } else { $this->bodyAttrs[$i] = $i1; } return $this; } public function body($i, $i1 = true, $i2 = []) { return $this->nodeBuilder('body', array_merge($i2, $this->bodyAttrs), false, $i, $i1); } private function addScript($i, $i1 = NULL, $i2 = NULL, $i3 = NULL, $i4 = false) { $i5 = parse_url($i); if (empty($i5)) throw new Tii_Application_Exception("url `%s' was invalid", $i); is_array($i2) || $i2 = []; if ($this->baseUrl && empty($i5['host'])) { $i = ($i{0} === '#') ? substr($i, 1) : Tii_Http::concat($this->baseUrl, $i); } $i2[$i4 ? 'href' : 'src'] = Tii_Http::urlAppend($i, ['v' => Tii::value($i1, Tii_Version::VERSION)]); $this->scripts[$i3][$i4 ? 'css' : 'script'][$i] = $i2; return $this; } public function addScripts(array $scripts, $i = NULL, $i1 = NULL, $i2 = NULL, $i3 = false) { foreach($scripts as $i4 => $i5) { if (is_numeric($i4)) { $this->addScript($i5, $i, $i1, $i2, $i3); } else { is_array($i5) || $i5 = ['ver' => $i5]; $this->addScript($i4, Tii::valueInArray($i5, 'ver', $i), Tii::valueInArray($i5, 'attr', $i1), $i2, $i3 ); } } return $this; } public function nodeBuilder($i, $i1, $i2 = true, $i3 = NULL, $i4 = true) { $i5 = []; foreach($i1 as $i6 => $i7) { $i5[] = sprintf('%s="%s"', $i6, str_replace('"', '\"', $i7)); } $i5 = $i5 ? " " .implode(" ", $i5) : ""; if ($i2) { return sprintf('<%s%s />', $i, $i5); } else { $i8 = []; $i8[] = sprintf('<%s%s>', $i, $i5); $i8[] = Tii::value($i3, ""); if ($i4) $i8[] = sprintf('</%s>', $i); return implode('', $i8); } } public function getScripts($i = NULL, $i1 = [], $i2 = 'script', $i3 = false) { $i4 = []; foreach(Tii::valueInArray($this->scripts[$i], $i3 ? 'css' : 'script', []) as $i5 => $i6) { $i4[] = $this->nodeBuilder($i2, array_merge($i6, $i1), $i3); } return implode("\n", $i4); } public function getCsses($i = NULL) { return $this->getScripts($i, [ 'rel' => "stylesheet", 'type' => "text/css", ], 'link', true); } public function block($i = NULL, $i1) { Tii_Event::register('tii.application.helper.html.'.$i, function($i2) use ($i1) { return $i2 . "\n" . $i1; }); } public function __call($i, $i1) { if (preg_match('#^add(.*)(Script|Css)(s|es)?$#iUs', $i, $i2)) { $i1 = array_pad($i1, 3, NULL); $i1[] = $i2[1]; $i1[] = strtolower($i2[2]) == 'css'; return call_user_func_array([$this, 'addScript' . (isset($i2[3]) ? 's' : '')], $i1); } else if (preg_match('#^get(.*)(Script|Css)(s|es)?$#iUs', $i, $i2)) { switch(strtolower($i2[2])) { case 'css': return call_user_func_array([$this, 'getCsses'], [$i2[1]]); break; case 'script': default: return call_user_func_array([$this, 'getScripts'], [$i2[1]]); } } else if (preg_match('#^get(.*)$#iUs', $i, $i2)) { $i3 = []; $i4 = strtolower($i2[1]); if ($i4 == 'header') { $i4 = ''; $i3[] = $this->title(); $i3[] = $this->metas(); } foreach(['Csses', 'Scripts'] as $i5) { $i6 = call_user_func_array([$this, sprintf('get%s%s', ucfirst($i4), $i5)], []); if ($i6) $i3[] = $i6; } return Tii_Event::filter('tii.application.helper.html.'.strtolower($i2[1]), implode("\n", $i3), $this); } else { array_unshift($i1, $i); return call_user_func_array([$this, 'block'], $i1); } } public function inputs($i, $i1 = NULL, $i2 = NULL) { static $i3; $i3 || $i3 = function($i4, $i5){ if (is_callable($i4)) return call_user_func($i4, $i5); else if (is_scalar($i4)) return $i4; else return serialize($i4); }; $i6 = []; foreach($i as $i5) { if ($i1) $i6[] = call_user_func_array($i3, [$i1, $i5]); $i6[] = $this->input($i5); if ($i2) $i6[] = call_user_func_array($i3, [$i2, $i5]); } return implode("\n", $i6); } public function input() { if (func_num_args() == 0) return false; $i = func_get_args(); if (is_array($i[0])) { $i1 = $i[0]; } else { $i1 = Tii::combiner($i, "type", "name", "value", "checked", "id", "class", "onchange"); } if (!is_bool($i1['checked']) && !in_array($i1['type'], ['text', 'password', 'hidden'])) { $i1['checked'] = strval($i1['value']) === strval($i1['checked']); } $i2 = $this->dom()->createElement("input"); foreach ($i1 as $i3 => $i4) { if ($i3 == "statement") continue; if ($i3 == "checked" && !$i4) continue; $i2->setAttribute($i3, $i4); } return $this->dom()->saveXML($i2); } public function select() { if (func_num_args() == 0) return false; $i = func_get_args(); if (is_array($i[0])) { $i1 = $i[0]; } else { $i1 = Tii::combiner($i, "name", "options", "selected", "id", "class", "onchange"); } $i2 = $this->dom()->createElement("select"); foreach($i1 as $i3 => $i4) { if ($i3 == "selected" || $i3 == "options") continue; $i2->setAttribute($i3, $i4); } $i5 = Tii::valueInArray($i1, 'selected', ''); if (is_array($i5)) $i2->setAttribute('multiple', 'multiple'); $i6 = (array)$i1['options']; foreach ($i6 as $i7 => $i8) { $i9 = $this->dom()->createElement("option"); $i9->setAttribute("value", $i7); if (strval($i7) === strval($i5) || (is_array($i5) && in_array($i7, $i5))) { $i9->setAttribute("selected", true); } $iA = $this->dom()->createTextNode(Tii::lang($i8)); $i9->appendChild($iA); $i2->appendChild($i9); } return $this->dom()->saveXML($i2); } }
 final class Tii_Dao_Common_QueryHelper { private $connection; private $queryKey; public function __construct(PDO $connection) { $this->connection = $connection; } public function setQueryKey($queryKey) { $queryKey = trim($queryKey); if ('' != $queryKey) $this->queryKey = $queryKey; return $this; } private function _unsetQueryKey() { $this->queryKey = NULL; return $this; } public function query($i, $i1 = NULL, $i2 = NULL, $i3 = NULL, $i4 = NULL, $i5 = NULL, $i6 = NULL, $i7 = NULL, $i8 = NULL) { if (is_array($i1)) { $i9 = $i1; $i1 = NULL; isset($i9['columns']) && $i1 = $i9['columns']; isset($i9['selection']) && $i2 = $i9['selection']; isset($i9['selection_args']) && $i3 = $i9['selection_args']; isset($i9['group_by']) && $i4 = $i9['group_by']; isset($i9['having']) && $i5 = $i9['having']; isset($i9['order_by']) && $i6 = $i9['order_by']; isset($i9['limit']) && $i7 = $i9['limit']; isset($i9['offset']) && $i8 = $i9['offset']; unset($i9); } $iA = $this->_buildQuerySql($i, $i1, $i2, $i4, $i5, $i6, $i7, $i8); return $this->doQuery($iA, $i3); } public function doQuery($i, $i1 = NULL) { $i2 = $this->connection->prepare($i); $this->bindParams($i2, $i1); $i2->execute(); $i3 = $i2->fetchAll(PDO::FETCH_ASSOC); if (!$this->queryKey) return $i3; if (!isset($i3[0]) || !isset($i3[0][$this->queryKey])) { $this->_unsetQueryKey(); return $i3; } $i4 = []; foreach ($i3 as $i5) { $i4[$i5[$this->queryKey]] = $i5; } $this->_unsetQueryKey(); return $i4; } public function listColumn($i, $i1 = NULL, $i2 = NULL, $i3 = NULL, $i4 = NULL, $i5 = NULL, $i6 = NULL, $i7 = NULL, $i8 = NULL) { if (is_array($i1)) { $i9 = $i1; $i1 = NULL; isset($i9['columns']) && $i1 = $i9['columns']; isset($i9['selection']) && $i2 = $i9['selection']; isset($i9['selection_args']) && $i3 = $i9['selection_args']; isset($i9['group_by']) && $i4 = $i9['group_by']; isset($i9['having']) && $i5 = $i9['having']; isset($i9['order_by']) && $i6 = $i9['order_by']; isset($i9['limit']) && $i7 = $i9['limit']; isset($i9['offset']) && $i8 = $i9['offset']; unset($i9); } $iA = $this->_buildQuerySql($i, $i1, $i2, $i4, $i5, $i6, $i7, $i8); $iB = $this->connection->prepare($iA); $this->bindParams($iB, $i3); $iB->execute(); return $iB->fetchAll(PDO::FETCH_COLUMN); } public function getColumn($i, $i1 = NULL, $i2 = NULL, $i3 = NULL, $i4 = NULL, $i5 = NULL, $i6 = NULL) { $i7 = false; if (is_array($i1)) { $i8 = $i1; $i1 = NULL; isset($i8['columns']) && $i1 = $i8['columns']; isset($i8['selection']) && $i2 = $i8['selection']; isset($i8['selection_args']) && $i3 = $i8['selection_args']; isset($i8['group_by']) && $i4 = $i8['group_by']; isset($i8['having']) && $i5 = $i8['having']; isset($i8['order_by']) && $i6 = $i8['order_by']; isset($i8['is_group_by_count']) && $i7 = $i8['is_group_by_count']; unset($i8); } $i9 = $i7 ? NULL : 1; $iA = $this->_buildQuerySql($i, $i1, $i2, $i4, $i5, $i6, $i9); $i7 && $iA = "SELECT COUNT(*) FROM ($iA) t"; $iB = $this->connection->prepare($iA); $this->bindParams($iB, $i3); $iB->execute(); return $iB->fetchColumn(); } public function get($i, $i1 = NULL, $i2 = NULL, $i3 = NULL, $i4 = NULL, $i5 = NULL, $i6 = NULL) { if (is_array($i1)) { $i7 = $i1; $i1 = NULL; isset($i7['columns']) && $i1 = $i7['columns']; isset($i7['selection']) && $i2 = $i7['selection']; isset($i7['selection_args']) && $i3 = $i7['selection_args']; isset($i7['group_by']) && $i4 = $i7['group_by']; isset($i7['having']) && $i5 = $i7['having']; isset($i7['order_by']) && $i6 = $i7['order_by']; unset($i7); } $i8 = $this->_buildQuerySql($i, $i1, $i2, $i4, $i5, $i6, 1); $i9 = $this->connection->prepare($i8); $this->bindParams($i9, $i3); $i9->execute(); $iA = $i9->fetch(PDO::FETCH_ASSOC); return !empty($iA) ? $iA : NULL; } public function insert($i, array $i1) { $i2 = $this->_buildInsertSql($i, $i1); $i3 = $this->connection->prepare($i2); $this->bindParams($i3, $i1); $i3->execute(); $i4 = $this->connection->lastInsertId(); return $i4 ? $i4 : $i3->rowCount(); } public function update($i, array $i1, $i2 = NULL, $i3 = NULL, array $i4 = []) { $i5 = $this->_buildUpdateSql($i, $i1, $i4, $i2); $i6 = $this->connection->prepare($i5); $this->bindParams($i6, $i1); $this->bindParams($i6, $i3, count($i1)); if (!$i6->execute()) return -1; return $i6->rowCount(); } public function delete($i, $i1 = NULL, $i2 = NULL) { $i3 = $this->_buildDeleteSql($i, $i1); $i4 = $this->connection->prepare($i3); $this->bindParams($i4, $i2); $i4->execute(); return $i4->rowCount(); } public function count($i, $i1 = NULL, $i2 = NULL, $i3 = NULL) { $i4 = $this->_buildCountSql($i, $i1, $i2); $i5 = $this->connection->prepare($i4); $this->bindParams($i5, $i3); $i5->execute(); return intval($i5->fetchColumn()); } public function duplicate($i, array $i1, array $i2 = [], array $i3 = []) { $i4 = $this->_buildDuplicateSql($i, $i1, $i2, $i3); $i5 = $this->connection->prepare($i4); $this->bindParams($i5, $i1); $this->bindParams($i5, $i2, count($i1)); $i5->execute(); return $i5->rowCount(); } public function execute($i) { $i1 = $this->connection->prepare($i); $i1->execute(); return $i1; } public function isTableExist($i) { $i1 = "SHOW TABLES LIKE " . $this->connection->quote($i); $i2 = $this->connection->prepare($i1); $i2->execute(); return (bool) $i2->fetchColumn(); } public function getFieldNames($i) { $i1 = "SHOW COLUMNS FROM " . $i; $i2 = $this->execute($i1)->fetchAll(PDO::FETCH_ASSOC); if (!$i2) []; $i3= []; foreach($i2 as $i4){ $i3[]= $i4['Field']; } return $i3; } public function dropTable($i) { return $this->execute("DROP TABLE $i"); } public static function buildBinary($i, $i1 = true, $i2 = 1) { if ($i <= 0 || $i2 <= 0 || (intval($i1) > (pow(2, $i2) - 1))) return false; $i1 = sprintf('%0' . $i2 . 'b', $i1); --$i; $i3 = []; $i3[] = '&~((pow(2, ' . $i2 . ') - 1)<<' . $i . ')'; for ($i4 = $i2 - 1; $i4 >= 0; $i4--) { if (isset($i1[$i4]) && $i1[$i4]) { $i3[] = '|(1<<' . $i . ')'; } else { $i3[] = '&~(1<<' . $i . ')'; } ++$i; } return implode('', $i3); } private function _buildQuerySql($i, $i1 = NULL, $i2 = NULL, $i3 = NULL, $i4 = NULL, $i5 = NULL, $i6 = NULL, $i7 = NULL) { $i8 = 'SELECT '; $i8 .= empty($i1) ? '* ' : $i1 . ' '; $i8 .= 'FROM ' . $i . ' '; $i8 .= empty($i2) ? '' : 'WHERE ' . $i2 . ' '; $i8 .= empty($i3) ? '' : 'GROUP BY ' . $i3 . ' '; $i8 .= empty($i4) ? '' : 'HAVING ' . $i4 . ' '; $i8 .= empty($i5) ? '' : 'ORDER BY ' . $i5 . ' '; if (!empty($i6) && $i6 > 0) { $i7 = (empty($i7) || $i7 < 0) ? 0 : $i7; $i8 .= 'LIMIT ' . $i7 . ', ' . $i6; } return $i8; } private function _buildInsertSql($i, $i1) { $i2 = "INSERT INTO {$i} ("; foreach (array_keys($i1) as $i3) { $i2 .= "`{$i3}`,"; } $i2 = rtrim($i2, ',') . ') VALUES ('; $i2 .= implode(array_fill(0, count($i1), '?'), ','); $i2 .= ')'; return $i2; } private function __buildUpdateSql(array $i, array $i1 = []) { $i2 = []; foreach (array_keys($i) as $i3) { list($i4, $i3) = explode('.', $i3); $i2[] = $i3 ? "$i4.`$i3`=?" : "`$i4`=?"; } foreach ($i1 as $i3 => $i5) { if (is_numeric($i3)) { $i2[] = $i5; continue; } if (is_numeric($i5)) { if ($i5 >= 0) { $i5 = '+' . $i5; } } $i5 = strval($i5); list($i4, $i3) = explode('.', $i3); $i2[] = $i3 ? "$i4.`$i3`=$i4.`$i3`$i5" : "`$i4`=`$i4`$i5"; } return implode(',', $i2) . ' '; } private function _buildUpdateSql($i, array $i1, array $i2, $i3) { $i4 = 'UPDATE ' . $i . ' '; $i4 .= 'SET '; $i4 .= $this->__buildUpdateSql($i1, $i2); $i4 .= empty($i3) ? '' : 'WHERE ' . $i3; return $i4; } private function _buildDuplicateSql($i, array $i1, array $i2 = [], array $i3 = []) { $i4 = $this->_buildInsertSql($i, $i1); $i4 .= ' ON DUPLICATE KEY UPDATE '; $i4 .= $this->__buildUpdateSql($i2, $i3); return $i4; } private function _buildDeleteSql($i, $i1) { $i2 = 'DELETE FROM ' . $i . ' '; $i2 .= empty($i1) ? '' : 'WHERE ' . $i1; return $i2; } private function _buildCountSql($i, $i1, $i2) { $i3 = 'SELECT COUNT('; $i3 .= empty($i1) ? '*' : $i1; $i3 .= ') FROM ' . $i . ' '; $i3 .= empty($i2) ? '' : 'WHERE ' . $i2; return $i3; } public static function buildWhere(array $i, array $i1 = []) { foreach ($i1 as $i2 => $i3) { if (!$i3) continue; list($i4, $i5) = self::__buildInFragment($i3); list($i6, $i2) = explode('.', $i2); $i[($i2 ? "$i6.`$i2`" : "`$i6`").$i4] = $i5; } if ($i) { $i7 = ""; $i8 = []; foreach ($i as $i9 => $i3) { (strpos($i9, '?') === false) && $i9 = $i9 . "=?"; is_array($i3) || $i3 = [$i3]; $iA = substr_count($i9, '?'); $iB = count($i3); if ($iA != $iB) { throw new Tii_Exception("inconsistent with [?/value]:%s/%s", $iA, $iB); } $i7 .= $i7 == "" ? $i9 : " AND " . $i9; foreach ($i3 as $iC) { $i8[] = $iC; } } return [$i7, $i8]; } return [NULL, NULL]; } private static function __buildInFragment(array $i) { if ($i) { $i1 = array_fill(0, count($i), '?'); return [" IN (" . implode(',', $i1) . ")", $i]; } return [NULL, NULL]; } public function bindParams(&$i, $i1, $i2 = 0) { $i1 = empty($i1) ? [] : array_values($i1); for ($i3 = 0; $i3 < count($i1); $i3++) { $i->bindParam($i2 + $i3 + 1, $i1[$i3]); } } public static function getPageOffset($i, $i1, $i2) { $i3 = ceil($i2 / $i1); $i = max(1, min($i3, intval($i))); return ($i - 1) * $i1; } }
 final class Tii_Dao_Common_PropelPDO extends PDO { const PROPEL_ATTR_CACHE_PREPARES = -1; protected $nestedTransactionCount = 0; protected $preparedStatements = []; protected $cachePreparedStatements = false; public function getNestedTransactionCount() { return $this->nestedTransactionCount; } protected function setNestedTransactionCount($i) { $this->nestedTransactionCount = $i; } protected function decrementNestedTransactionCount() { $this->nestedTransactionCount--; } protected function incrementNestedTransactionCount() { $this->nestedTransactionCount++; } public function isInTransaction() { return ($this->getNestedTransactionCount() > 0); } public function beginTransaction() { $i = true; $i1 = $this->getNestedTransactionCount(); if ( $i1 === 0 ) { $i = parent::beginTransaction(); } $this->incrementNestedTransactionCount(); return $i; } public function commit() { $i = true; $i1 = $this->getNestedTransactionCount(); if ($i1 > 0) { if ($i1 === 1) { $i = parent::commit(); } $this->decrementNestedTransactionCount(); } return $i; } public function rollBack() { $i = true; $i1 = $this->getNestedTransactionCount(); if ($i1 > 0) { if ($i1 === 1) { $i = parent::rollBack(); } $this->decrementNestedTransactionCount(); } return $i; } public function setAttribute($i, $i1) { switch($i) { case self::PROPEL_ATTR_CACHE_PREPARES: $this->cachePreparedStatements = $i1; break; default: parent::setAttribute($i, $i1); } } public function getAttribute($i) { switch($i) { case self::PROPEL_ATTR_CACHE_PREPARES: return $this->cachePreparedStatements; break; default: return parent::getAttribute($i); } } public function prepare($i, $i1 = []) { if ($this->cachePreparedStatements) { $i2 = $i; if (array_key_exists($i2, $this->preparedStatements)) { return $this->preparedStatements[$i2]; } else { $i3 = parent::prepare($i, $i1); $this->preparedStatements[$i2] = $i3; return $i3; } } else { return parent::prepare($i, $i1); } } public function clearStatementCache() { $this->preparedStatements = []; } }
 class Tii_Worker_Event_Libevent extends Tii_Worker_Event_Abstract { protected $base = null; public function __construct() { $this->base = event_base_new(); } public function add($i, $i1, $i2, $i3 = []) { switch ($i1) { case self::EV_SIGNAL: $i4 = (int)$i; $this->signals[$i4] = event_new(); if (!event_set($this->signals[$i4], $i, EV_SIGNAL | EV_PERSIST, $i2, null)) { return false; } if (!event_base_set($this->signals[$i4], $this->base)) { return false; } if (!event_add($this->signals[$i4])) { return false; } return true; case self::EV_TIMER: case self::EV_TIMER_ONCE: $i5 = event_new(); $i6 = (int)$i5; if (!event_set($i5, 0, EV_TIMEOUT, [$this, 'timerCallback'], $i6)) { return false; } if (!event_base_set($i5, $this->base)) { return false; } $i7 = $i * 1000000; if (!event_add($i5, $i7)) { return false; } $this->timers[$i6] = [$i2, $i3, $i1, $i5, $i7]; return $i6; default : $i4 = (int)$i; $i8 = $i1 === self::EV_READ ? EV_READ | EV_PERSIST : EV_WRITE | EV_PERSIST; $i5 = event_new(); if (!event_set($i5, $i, $i8, $i2, null)) { return false; } if (!event_base_set($i5, $this->base)) { return false; } if (!event_add($i5)) { return false; } $this->events[$i4][$i1] = $i5; return true; } } public function delete($i, $i1) { switch ($i1) { case self::EV_READ: case self::EV_WRITE: $i2 = (int)$i; if (isset($this->events[$i2][$i1])) { event_del($this->events[$i2][$i1]); unset($this->events[$i2][$i1]); } if (empty($this->events[$i2])) { unset($this->events[$i2]); } break; case self::EV_SIGNAL: $i2 = (int)$i; if (isset($this->signals[$i2])) { event_del($this->signals[$i2]); unset($this->signals[$i2]); } break; case self::EV_TIMER: case self::EV_TIMER_ONCE: if (isset($this->timers[$i])) { event_del($this->timers[$i][3]); unset($this->timers[$i]); } break; } return true; } protected function timerCallback($i, $i1, $i2) { list($i3, $i4, $i5, $i6, $i7) = $this->timers[$i2]; if ($i5 === self::EV_TIMER) { event_add($i6, $i7); } try { call_user_func_array($i3, $i4); } catch (Exception $i8) { Tii_Logger::debug($i8->getMessage()); exit(250); } if (isset($this->timers[$i2]) && $i5 === self::EV_TIMER_ONCE) { $this->del($i2, self::EV_TIMER_ONCE); } } public function clearAllTimer() { foreach ($this->timers as $i) { event_del($i[3]); } $this->timers = []; } public function loop() { event_base_loop($this->base); } }
 final class Tii_Config { private static $dirs = []; public static $lang = 'default'; private static $configs = []; public static function setDir($i) { if (!is_dir($i)) { trigger_error("invalid path `$i'!!!", E_USER_ERROR); return false; } $i = rtrim($i, '\\/'); self::$dirs = [ $i . '/local', $i, $i . '/..', ]; $i1 = self::get('tii.library.include', []); if ($i1) { is_array($i1) && $i1 = implode(PATH_SEPARATOR, $i1); set_include_path($i1 . PATH_SEPARATOR . get_include_path()); } return true; } protected static function getDirs($i = NULL) { if (empty(self::$dirs)) { trigger_error("Configured first, Usage: Tii_Config::setDir('/path/to/config/folder')", E_USER_WARNING); self::setDir(TII_DIRECTORY . '/.configs'); } return is_null($i) ? self::$dirs : self::$dirs[$i]; } protected static function loader($i = 'tii') { foreach (self::getDirs() as $i1) { $i2 = $i1 . '/' . $i . '.config.php'; if (is_file($i2)) { self::set($i, include $i2); return true; } } return false; } public static function getIdentifier() { static $i; isset($i) || $i = Tii_Math::hashStr(self::getDirs(0)); return $i; } public static function set($i, $i1 = NULL) { return Tii::setter(self::$configs, $i, $i1); } public static function get($i, $i1 = NULL) { $i2 = Tii::getter(self::$configs, $i); if (!is_null($i2)) return $i2; if (strpos($i, '.') !== false) { list($i3) = explode('.', $i, 2); } else { $i3 = $i; } self::loader($i3); return Tii::getter(self::$configs, $i, $i1); } public static function _lang($i) { return 'lang-' . self::$lang . '.' . $i; } public static function lang() { $i = func_get_args(); if (isset($i[0])) { $i[0] = self::get(self::_lang($i[0]), $i[0]); } return call_user_func_array('sprintf', $i); } public static function isDebugMode() { return (bool)self::get('tii.debug_mode', false); } }
 class Tii_Application_Helper_Dao extends Tii_Application_Abstract { public function queryService(Tii_Dao $i, $i1, array $i2 = []) { if ($i3 = Tii::valueInArray($i2, 'selection')) { $i4 = Tii::valueInArray($i2, 'selection_args'); } else { $i4 = NULL; } $i5 = Tii::valueInArray($i2, 'page', 1); $i6 = Tii::valueInArray($i2, 'perpage', 200); $i7 = Tii::valueInArray($i2, 'total'); is_numeric($i7) || $i7 = $this->getSimpleTotalNumber($i, $i1, [ 'columns' => Tii::valueInArray($i2, 'total_columns', "count(*) as c"), 'selection' => Tii::valueInArray($i2, 'selection'), 'selection_args' => $i4, 'group_by' => Tii::valueInArray($i2, 'group_by'), 'having' => Tii::valueInArray($i2, 'having'), ]); $i8 = [ 'page' => $i5, 'perpage' => $i6, 'total' => $i7, 'offset' => Tii_Dao_Common_QueryHelper::getPageOffset($i5, $i6, $i7), ]; $i9 = [ 'columns' => Tii::valueInArray($i2, 'columns', "*"), 'selection' => Tii::valueInArray($i2, 'selection'), 'selection_args' => $i4, 'group_by' => Tii::valueInArray($i2, 'group_by'), 'having' => Tii::valueInArray($i2, 'having'), 'order_by' => Tii::valueInArray($i2, 'order_by'), 'limit' => $i8['perpage'], 'offset' => $i8['offset'], ]; $i8['items'] = $this->simpleQuery($i, $i1, $i9); return $i8; } public function simpleQueryService(Tii_Dao $i, $i1) { return $this->queryService($i, $i1, $this->getRequests()); } public function simpleQuery(Tii_Dao $i, $i1, array $i2) { return $i->getQueryHelper()->query( $i1, $i2 ); } public function getSimpleTotalNumber(Tii_Dao $i, $i1, array $i2) { unset($i2['order_by'],$i2['limit'],$i2['offset'],$i2['columns']); $i2['columns'] = 'count(*)'; isset($i2['group_by']) && $i2['is_group_by_count'] = true; return intval($i->getQueryHelper()->getColumn( $i1, $i2 )); } } 
 class Tii_Application_Processor_Cli_Response { private $colors = []; public function __construct() { $this->colors = array_flip([30 => 'gray', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'white', 'black']); } public function displayHelp() { printf("usage: php shell --timeout=0 --memory=128M module controller[index] action[index] --param=value"); exit; } public function setProcessTitle($i) { if (function_exists('cli_set_process_title')) { @cli_set_process_title($i); } elseif (extension_loaded('proctitle') && function_exists('setproctitle')) { @setproctitle($i); } } public function println() { echo call_user_func_array([Tii_Application::getInstance(), 'lang'], func_get_args()). PHP_EOL; } public function colorize($i, $i1, $i2 = false) { return"\033[" . ($i2 ? '1' : '0') . ';' . $this->colors[$i1] . "m$i\033[0m"; } public function __call($i, $i1) { if (isset($this->colors[$i])) { $i2 = array_shift($i1); array_unshift($i1, $i2, $i); return call_user_func_array([$this, 'colorize'], $i1); } } }
 class Tii_Application_Helper_Csrf extends Tii_Application_Abstract { public function getName() { static $i; $i || $i = Tii::get('tii.application.helper.csrf.name', '__csrf_token__'); return $i; } public function getValue() { $i = $this->getSession($this->getName()); if (empty($i)) { $i = Tii_Math::random(16); $this->getResponse()->setSession($this->getName(), $i); } return $i; } public function getInput() { return sprintf('<input name="%s" type="hidden" value="%s" />', $this->getName(), $this->getValue()); } public function check() { $i = $this->getRequest($this->getName()); if (empty($i)) return false; return ($this->getValue() === $i); } public function validator($i = true) { if (($i && !$this->isPost()) || !$this->check()) { throw new Tii_Application_Exception("CSRF security error"); } return true; } }
 class Tii_Cache_Array extends Tii_Cache_Abstract { private $expiredTimes = []; private $data = []; private function clearExpired() { $i = microtime(true); foreach($this->expiredTimes as $i1 => $i2) { $i2 -= $i; if (!$i2) { unset($this->expiredTimes[$i1], $this->data[$i1]); } } } public function isSupported() { return true; } public function set($i, $i1, $i2 = 0, $i3 = 0) { if ($i3) { $this->cachedTime[$i] = microtime(true) + $i3; } $this->data[$i] = $i1; $this->clearExpired(); return true; } public function add($i, $i1, $i2 = 0, $i3 = 0) { if (isset($this->data[$i])) return false; return $this->set($i, $i1, $i2, $i3); } public function replace($i, $i1, $i2 = 0, $i3 = 0) { if (!isset($this->data[$i])) return false; return $this->set($i, $i1, $i2, $i3); } public function increment($i, $i1 = 1) { if (!isset($this->data[$i])) return false; $this->data[$i] += $i1; return true; } public function decrement($i, $i1 = 1) { if (!isset($this->data[$i])) return false; $this->data[$i] -= $i1; return true; } public function get($i) { $this->clearExpired(); return $this->data[$i]; } public function delete($i, $i1 = 0) { if ($i1) { $this->cachedTime[$i] = microtime(true) + $i1; } else { unset($this->data[$i]); } $this->clearExpired(); return true; } public function lock($i, $i1 = 60) { if ($this->get($i)) { return false; } return $this->set($i, true, 0, $i1); } public function unlock($i) { if (!$this->get($i)) { return false; } return $this->delete($i); } public function flush() { $this->expiredTimes = []; $this->data = []; } }
 class Tii_Cache_Apc extends Tii_Cache_Abstract { public function isSupported() { return function_exists('apc_fetch'); } public function set($i, $i1, $i2 = 0, $i3 = 0) { return apc_store($i, $i1, $i3); } public function add($i, $i1, $i2 = 0, $i3 = 0) { return apc_add($i, $i1, $i3); } public function replace($i, $i1, $i2 = 0, $i3 = 0) { if (!apc_exists($i)) return false; return $this->set($i, $i1, $i2, $i3); } public function increment($i, $i1 = 1) { apc_inc($i, $i1, $i2); return $i2; } public function decrement($i, $i1 = 1) { apc_dec($i, $i1, $i2); return $i2; } public function get($i) { return apc_fetch($i); } public function delete($i, $i1=0) { return apc_delete($i); } public function lock($i, $i1 = 60) { if ($this->get($i)) { return false; } ignore_user_abort(true); return $this->set($i, true, 0, $i1); } public function unlock($i) { if (!$this->get($i)) { return false; } return $this->delete($i); } public function flush() { apc_clear_cache(); } }
 class Tii_Application_Helper_Ajax extends Tii_Application_Abstract { public function display($i) { $this->noRender(); $this->getResponse()->setHeader('Content-Type', 'application/json; charset=utf-8'); $this->callResponseFunc(function($i1){ echo $i1;}, $i); } }
 final class Tii_Application_Helper { private $namespace; public function __construct($namespace = 'Tii') { $this->namespace = $namespace; } public function __call($i, $i1) { return Tii::objective( Tii::className($this->namespace, 'Application', 'Helper', $i), $i1 ); } }
 final class Tii_Application { private $error; public static function getInstance() { static $i; $i || $i = new self; return $i; } public static function run() { if (Tii::get('tii.timezone')) { Tii_Time::timezone(Tii::get('tii.timezone')); } Tii_Event::init(); try { self::getInstance()->execute(); self::getInstance()->getProcessor()->over(); } catch (Exception $i) { self::getInstance()->setError($i); try { self::getInstance()->execute('error', 'error'); self::getInstance()->getProcessor()->over(); } catch (Exception $i1) { try { self::getInstance()->execute('error', 'error', 'default'); self::getInstance()->getProcessor()->over(); } catch (Exception $i2) { trigger_error($i2->getMessage(), E_USER_ERROR); } } } } public function getDispatcher() { return $this; } public function getProcessor($i = false) { static $i1; if ($i) { $i1 = null; return false; } if ($i1) return $i1; $i1 = TII_PROCESSOR; $i1 = new $i1; $i1 = Tii_Event::filter('tii.application.processor', $i1); return $i1; } protected function loadControllerInstance($i, $i1) { $i2 = Tii::filename('controllers', $i, $i1, 'php'); if (!is_file($i2)) { throw new Tii_Application_Exception("controller file `%s' not exist", $i2); } try { require_once $i2; return Tii::object(str_replace('-', '_', sprintf('%s_%sController', $i, $i1))); } catch (Exception $i3) { throw new Tii_Application_Exception("load controller `%s.%s` failed", $i, $i1); } } public function execute($i = NULL, $i1 = NULL, $i2 = NULL) { $i3 = $this->getProcessor(); $i2 || $i2 = $i3->getModuleName(); $i1 || $i1 = $i3->getControllerName(); $i || $i = $i3->getActionName(); $i4 = $this->loadControllerInstance($i2, $i1); $i5 = sprintf('%sAction', str_replace('-', '_', $i)); if (!method_exists($i4, $i5)) { throw new Tii_Application_Exception("action `%s.%s.%s' not exist", $i2, $i1, $i); } $i4->setModuleName($i2); $i4->setControllerName($i1); $i4->setActionName($i); try { foreach(['init', $i5, 'over'] as $i6) { if ($i4->isInterrupt()) break; call_user_func([$i4, $i6]); } } catch (Tii_Application_IgnoreException $i7) { } catch (Exception $i7) { call_user_func([$i4, 'error'], $i7); } } public function setError($error) { $this->error = $error; } public function getError() { return $this->error; } public function __call($i, $i1) { if (is_callable([$this->getProcessor(), $i])) { return call_user_func_array([$this->getProcessor(), $i], $i1); } } }
 class Tii_Application_SessionHandler_Dao implements SessionHandlerInterface { private $maxlifetime = 0; private $dao; private $table; private $fields = [ 'session_id' => 'id', 'session_data' => 'data', 'session_expired' => 'expired', ]; public function __construct($dao = NULL, $table = 'session', $fields = []) { $this->dao = ($dao instanceof Tii_Dao) ? $dao : Tii::object('Tii_Dao', $dao); $this->table = $table; $this->fields = array_merge($this->fields, $fields); $this->maxlifetime = ini_get('session.gc_maxlifetime'); } public function open($i, $i1) { return $this->dao->isTableExist($this->table); } public function close() { return true; } public function read($i) { $i1 = $this->dao->get($this->table, [ 'columns' => $this->fields['session_data'], 'selection' => sprintf('%s=? and %s>?', $this->fields['session_id'], $this->fields['session_expired']), 'selection_args' => [$i, time()], ]); if ($i1) return $i1[$this->fields['session_data']]; else return false; } public function write($i, $i1) { $i2 = [ $this->fields['session_id'] => $i, $this->fields['session_data'] => $i1, $this->fields['session_expired'] => time() + $this->maxlifetime, ]; return $this->dao->duplicate($this->table, $i2, $i2); } public function destroy($i) { return $this->dao->delete($this->table, sprintf('%s=?', $this->fields['session_id']), [$i]); } public function gc($maxlifetime) { return $this->dao->delete($this->table, sprintf('%s<?', $this->fields['session_expired']), [time()]); } }
 class Tii_Application_Helper_Template extends Tii_Application_Abstract { protected $patterns = []; protected $replacements = []; public function __construct() { $i = Tii::get('tii.application.helper.template.filters', []); $this->patterns = array_keys($i); $this->replacements = array_values($i); } public function compile($i) { return preg_replace($this->patterns, $this->replacements, $i); } public function file($i) { if (file_exists($i)) { return $this->code(file_get_contents($i)); } else { throw new Tii_Application_Controller_Exception("missing template file `%s'", $i); } } public function code($i) { $i1 = Tii_Filesystem::hashfile($i, 'template', '.phtml'); if (!file_exists($i1)) { $i2 = @file_put_contents($i1, $this->compile($i)); if ($i2 == false) { throw new Tii_Application_Controller_Exception("unable to write to file `%s'", $i1); } } return $i1; } }
 class Tii_Worker_Event_Event extends Tii_Worker_Event_Abstract { protected $base = null; public function __construct() { $this->base = new EventBase(); } public function add($i, $i1, $i2, $i3=[]) { switch ($i1) { case self::EV_SIGNAL: $i4 = (int)$i; $i5 = Event::signal($this->base, $i, $i2); if (!$i5||!$i5->add()) { return false; } $this->signals[$i4] = $i5; return true; case self::EV_TIMER: case self::EV_TIMER_ONCE: $i6 = [$i2, $i3, $i1, $i, self::$id]; $i5 = new Event($this->base, -1, Event::TIMEOUT|Event::PERSIST, [$this, "timerCallback"], $i6); if (!$i5||!$i5->addTimer($i)) { return false; } $this->timers[self::$id] = $i5; return self::$id++; default : $i4 = (int)$i; $i7 = $i1 === self::EV_READ ? Event::READ | Event::PERSIST : Event::WRITE | Event::PERSIST; $i5 = new Event($this->base, $i, $i7, $i2, $i); if (!$i5||!$i5->add()) { return false; } $this->events[$i4][$i1] = $i5; return true; } } public function delete($i, $i1) { switch ($i1) { case self::EV_READ: case self::EV_WRITE: $i2 = (int)$i; if (isset($this->events[$i2][$i1])) { $this->events[$i2][$i1]->del(); unset($this->events[$i2][$i1]); } if (empty($this->events[$i2])) { unset($this->events[$i2]); } break; case self::EV_SIGNAL: $i2 = (int)$i; if (isset($this->signals[$i2])) { $this->events[$i2][$i1]->del(); unset($this->signals[$i2]); } break; case self::EV_TIMER: case self::EV_TIMER_ONCE: if (isset($this->timers[$i])) { $this->timers[$i]->del(); unset($this->timers[$i]); } break; } return true; } public function timerCallback($i, $i1, $i2) { list($i3, $i4, $i5, $i, $id) = $i2; if ($i5 === self::EV_TIMER_ONCE) { $this->timers[$id]->del(); unset($this->timers[$id]); } try { call_user_func_array($i3, $i4); } catch (Exception $i6) { Tii_Logger::debug($i6->getMessage()); exit(250); } } public function clearAllTimer() { foreach ($this->timers as $i) { $i->del(); } $this->timers = []; } public function loop() { $this->base->loop(); } }
 class Tii_Worker_Event_Ev extends Tii_Worker_Event_Abstract { public function add($i, $i1, $i2, $i3 = []) { $i4 = function ($i5, $i6) use ($i, $i2) { try { call_user_func($i2, $i); } catch (Exception $i7) { Tii_Logger::debug($i7->getMessage()); exit(250); } }; switch ($i1) { case self::EV_SIGNAL: $this->signals[$i] = new EvSignal($i, $i4); return true; case self::EV_TIMER: case self::EV_TIMER_ONCE: $i8 = $i1 == self::EV_TIMER_ONCE ? 0 : $i; $i9 = [$i2, $i3, $i1, $i, self::$id]; $this->timers[self::$id] = new EvTimer($i, $i8, [$this, 'timerCallback'], $i9); return self::$id++; default : $iA = (int)$i; $iB = $i1 === self::EV_READ ? Ev::READ : Ev::WRITE; $i5 = new EvIo($i, $iB, $i4); $this->events[$iA][$i1] = $i5; return true; } } public function delete($i, $i1) { switch ($i1) { case self::EV_READ: case self::EV_WRITE: $i2 = (int)$i; if (isset($this->events[$i2][$i1])) { $this->events[$i2][$i1]->stop(); unset($this->events[$i2][$i1]); } if (empty($this->events[$i2])) { unset($this->events[$i2]); } break; case self::EV_SIGNAL: $i2 = (int)$i; if (isset($this->signals[$i2])) { $this->events[$i2][$i1]->stop(); unset($this->signals[$i2]); } break; case self::EV_TIMER: case self::EV_TIMER_ONCE: if (isset($this->timers[$i])) { $this->timers[$i]->stop(); unset($this->timers[$i]); } break; } return true; } public function timerCallback($i) { list($i1, $i2, $i3, $i4, $id) = $i->data; if ($i3 === self::EV_TIMER_ONCE) { $this->timers[$id]->stop(); unset($this->timers[$id]); } try { call_user_func_array($i1, $i2); } catch (Exception $i5) { Tii_Logger::debug($i5->getMessage()); exit(250); } } public function clearAllTimer() { foreach ($this->timers as $i) { $i->stop(); } $this->timers = []; } public function loop() { Ev::run(); } }
 class Tii_Application_Processor_Http extends Tii_Application_Processor_Abstract { private $requestPath; private $layout; private $render; private $viewFormat = NULL; public function __construct() { if (!$this->checkAccess()) { header("HTTP/1.0 403 Forbidden"); header("X-Accessed-IP: " . $this->getIp()); echo Tii::get('tii.application.server.access.message', 'Access to this resource on the server is denied!'); exit; } parent::__construct(); if (!isset($_SERVER['HTTP_ACCEPT_ENCODING']) || !substr_count($_SERVER['HTTP_ACCEPT_ENCODING'], 'gzip') || !is_callable("ob_gzhandler") || !ob_start("ob_gzhandler")) { ob_start(); } ob_implicit_flush(0); $this->urlParser(); Tii_Event::register('tii.application.processor.http.view.formats', function($i) { $i['json'] = function($i1){return json_encode($i1);}; $i['serialize'] = function($i1){return serialize($i1);}; $i['txt'] = function($i1){return $i1;}; return $i; }); } private function checkAccess() { $i = (bool)Tii::get('tii.application.server.access.enable', false); if (!$i) return true; return Tii_Network::ipInRanges( $this->getIp(), Tii::get('tii.application.server.access.rules', []), true ); } protected function doBusyError($i, $i1) { header("HTTP/1.0 503 Service Unavailable"); echo Tii::get('tii.application.server.busy_error.message_html', 'Server too busy. Please try again later.'); exit; } public function viewCached() { $i = func_get_args(); if (empty($i)) return false; $i1 = array_shift($i); $i2 = sprintf("tii.viewCached.%s.%s.%s.%s.", Tii_Config::getIdentifier(), $this->getModuleName(), $this->getControllerName(), $this->getActionName() ); $i3 = implode('.', array_map(function($i4){return is_scalar($i4) ? strval($i4) : serialize($i4);}, $i)); $i3 = preg_replace('/\s+/', '', $i3); if ((($i5 = strlen($i3)) >= 250) || ($i5 + strlen($i2) >= 250)) { $i3 = md5($i3); } $i3 = $i2 . $i3; $this->setPair("expired", (int)$i1, 'view.cached'); $this->setPair("key", $i3, 'view.cached'); if ($i6 = Tii::object("Tii_Cache")->get($i3)) { $this->setPair("cached", $i6, 'view.cached'); throw new Tii_Application_IgnoreException("via cached: %s", $i3); } return $i3; } public function assign($i, $i1 = NULL) { return $this->setPair($i, $i1, 'view'); } public function assignAll($i) { return $this->setPairs($i, 'view'); } public function get($i, $i1 = NULL) { return $this->getPair($i, $i1, 'view'); } public function getView($i = []) { return $this->getPairs($i, 'view'); } public function getServerProtocol() { return $_SERVER['SERVER_PROTOCOL']; } public function getRequestMethod() { return $_SERVER['REQUEST_METHOD']; } public function getHost() { return $_SERVER['HTTP_HOST']; } public function getReferer() { return $_SERVER['HTTP_REFERER']; } public function getUserAgent() { return $_SERVER['HTTP_USER_AGENT']; } public function getIp() { static $i = NULL; static $i1 = '/^([0-9]{1,3}\.){3}[0-9]{1,3}$/'; if (isset($i)) return $i; if (array_key_exists('HTTP_X_FORWARDED_FOR', $_SERVER) && array_key_exists('REMOTE_ADDR', $_SERVER)) { if (strstr($_SERVER['HTTP_X_FORWARDED_FOR'], ',')) { $i2 = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']); $_SERVER['HTTP_X_FORWARDED_FOR'] = trim(end($i2)); } if (preg_match($i1, $_SERVER['HTTP_X_FORWARDED_FOR'])) { return $i = $_SERVER['HTTP_X_FORWARDED_FOR']; } } elseif (array_key_exists('HTTP_CLIENT_IP', $_SERVER) && preg_match($i1, $_SERVER['HTTP_CLIENT_IP'])) { return $i = $_SERVER['HTTP_CLIENT_IP']; } if (preg_match($i1, $_SERVER['REMOTE_ADDR'], $i3)) { return $i = $_SERVER['REMOTE_ADDR']; } return $i = 'Unknown'; } public function getRequestUri() { static $i = NULL; if (isset($i)) return $i; $i = $_SERVER['REQUEST_URI']; $i1 = [ 'HTTP_X_ORIGINAL_URL', 'HTTP_X_REWRITE_URL', 'REDIRECT_URL' ]; foreach ($i1 as $i2) { if (isset($_SERVER[$i2])) { $i = $_SERVER[$i2]; break; } } $i3 = Tii::get('tii.application.rewrite.http', []); if (count($i3) > 0) { if (isset($i3['*'])) { $i = call_user_func($i3['*'], $i); unset($i3['*']); } $i = preg_replace(array_keys($i3), array_values($i3), $i); } return $i; } public function getRequestUrl($i = NULL) { return sprintf('http%s://%s%s', $this->isHttps()?"s":"", $this->getHost(), $i?:$this->getRequestUri()); } public function getRequestPath() { return $this->requestPath; } public function getHeaders() { static $i = NULL; if (isset($i)) return $i; if (isset($_SERVER['PHP_AUTH_DIGEST'])) { $i1['Authorization'] = $_SERVER['PHP_AUTH_DIGEST']; } elseif (isset($_SERVER['PHP_AUTH_USER']) && isset($_SERVER['PHP_AUTH_PW'])) { $i1['Authorization'] = base64_encode($_SERVER['PHP_AUTH_USER'] . ':' . $_SERVER['PHP_AUTH_PW']); } if (isset($_SERVER['CONTENT_LENGTH'])) { $i1['Content-Length'] = $_SERVER['CONTENT_LENGTH']; } if (isset($_SERVER['CONTENT_TYPE'])) { $i1['Content-Type'] = $_SERVER['CONTENT_TYPE']; } foreach ($_SERVER as $i2 => $i3) { if ('HTTP_' == substr($i2, 0, 5)) { $i[str_replace('_', '-', ucwords(strtolower(substr($i2, 5)), '_-'))] = $i3; } } return $i; } public function getHeader($i, $i1 = NULL) { $i2 = $this->getHeaders(); $i = str_replace('_', '-', ucwords(strtolower($i), '_-')); return isset($i2[$i]) ? $i2[$i] : $i1; } public function getBody() { return @file_get_contents('php://input'); } public function setCookie($i, $i1, $i2 = 0) { $i3 = Tii::get('tii.controller.cookie.path', '/'); $i4 = Tii::get('tii.controller.cookie.domain', NULL); $i5 = Tii::get('tii.controller.cookie.secure', false); $i6 = Tii::get('tii.controller.cookie.httponly', false); return $this->getResponse()->setCookie($i, $i1, $i2, $i3, $i4, $i5, $i6); } public function getCookies() { $i = []; foreach ($_COOKIE as $i1 => $i2) { if ($i1{0} === '_') { $i[$i1] = Tii_Security_Encryption::decode($i2); } else { $i[$i1] = $i2; } } return $i; } public function getCookie($i, $i1 = NULL, $i2 = true) { $i = str_replace('.', '_', $i); return isset($_COOKIE[$i]) ? ( $i2 ? ( ($i{0} === '_') ? Tii_Security_Encryption::decode($_COOKIE[$i]) : $_COOKIE[$i] ) : $_COOKIE[$i]) : $i1; } public function getQueries() { return $_GET; } public function getQuery($i, $i1 = NULL) { return Tii::valueInArray($_GET, $i, $i1); } public function getPosts() { return $_POST; } public function getPost($i, $i1 = NULL) { return Tii::valueInArray($_POST, $i, $i1); } public function getRequests() { return array_merge($_REQUEST, $this->getPairs()); } public function getRequest($i, $i1 = NULL) { return Tii::valueInArray($this->getRequests(), $i, $i1); } public function getFiles() { return $_FILES; } public function getFile($i, $i1 = NULL) { return Tii::valueInArray($_FILES, $i, $i1); } public function getSessions() { return $_SESSION; } public function getSession($i, $i1 = NULL) { return Tii::valueInArray($_SESSION, $i, $i1); } public function isXmlHttpRequest() { return isset($_SERVER['HTTP_X_REQUESTED_WITH']) && $_SERVER['HTTP_X_REQUESTED_WITH'] === 'XMLHttpRequest'; } public function isPost() { return $this->getRequestMethod() === 'POST'; } public function isHttps() { return isset($_SERVER['HTTPS']) && $_SERVER["HTTPS"] === "on"; } public function isMobile() { static $i = NULL; if (isset($i)) return $i; $i1 = $this->getUserAgent(); if (empty($i1)) { $i = false; } elseif (strpos($i1, 'Mobile') !== false || strpos($i1, 'Android') !== false || strpos($i1, 'Silk/') !== false || strpos($i1, 'Kindle') !== false || strpos($i1, 'BlackBerry') !== false || strpos($i1, 'Opera Mini') !== false || strpos($i1, 'Opera Mobi') !== false ) { $i = true; } else { $i = false; } return $i; } public function isRobot() { static $i = NULL; if (isset($i)) return $i; if (empty($_SERVER['HTTP_USER_AGENT'])) { $i = false; } elseif (preg_match('/Googlebot|msnbot|bingbot|Slurp|Yahoo|Baiduspider/i', $_SERVER['HTTP_USER_AGENT'])) { $i = true; } elseif (preg_match('/robot|bot|spider|crawler/i', $_SERVER['HTTP_USER_AGENT'])) { $i = true; } elseif (preg_match('/appie|Arachnoidea|W3C-checklink|Extractor|HTTrack/i', $_SERVER['HTTP_USER_AGENT'])) { $i = true; } else { $i = false; } return $i; } public function setRender($render = NULL) { $this->render = $render; return $this; } public function noRender($viewFormat = NULL, $i = false) { if ($viewFormat) { $this->viewFormat = $this->viewFormat ? ($i ? $viewFormat : $this->viewFormat) : $viewFormat; } return $this->setRender(NULL); } public function getRender() { return $this->render; } public function getViewFormat() { return $this->viewFormat; } public function setLayout($layout = "default") { $this->layout = $layout; return $this; } public function noLayout() { $this->setLayout(NULL); return $this; } public function getLayout() { return $this->layout; } public function getResponse() { return Tii::object('Tii_Application_Processor_Http_Response'); } public function over() { if ($this->getRender()) { if ($this->isXmlHttpRequest()) { $this->getResponse()->setHeader("Expires", "Thu, 01 Jan 1970 00:00:01 GMT"); $this->getResponse()->setHeader('Cache-Control', "Cache-Control: no-store, no-cache, must-revalidate"); } else { $this->getResponse()->setHeader('Content-Type', 'text/html; charset=utf-8'); } } else { switch($this->viewFormat) { case 'json': $this->getResponse()->setHeader('Content-Type', 'application/json; charset=utf-8'); break; default: break; } } if ($i = $this->getPair('cached', NULL, 'view.cached')) { $this->getResponse()->setHeader('viaCached', 'true'); if (Tii_Config::isDebugMode()) { $this->getResponse()->setHeader('viaCacheKey', $this->getPair('key', NULL, 'view.cached')); } $this->callResponseFunc(function($i1){ echo $i1;}, Tii_Event::filter( 'tii.application.processor.http.response.cached', $i )); return; } $i2 = (int)$this->getPair('expired', 0, 'view.cached'); if ($this->getRender()) { $render = new Tii_Application_Processor_Http_Render(); $this->callResponseFunc([$render, 'display'], $i2); } else { $i3 = Tii::valueInArray( Tii_Event::filter('tii.application.processor.http.view.formats', []), $this->viewFormat ); $i4 = is_callable($i3) ? call_user_func($i3, Tii_Event::filter('tii.application.processor.http.getView', $this->getView())) : ""; $this->callResponseFunc(function($i1){ echo $i1;}, $i4); $this->cachingViewData($i2, $i4); } } public function cachingViewData($i, $i1) { if ($i <= 0) return; Tii_Event::register('tii.shutdown.handler', function() use($i, $i1) { Tii::object("Tii_Cache")->set($this->getPair('key', NULL, 'view.cached'), $i1, 0, $i); }, 10); } public function callResponseFunc() { $i = func_get_args(); $i1 = array_shift($i); if (function_exists('fastcgi_finish_request')) { $this->getResponse()->setHeader('Tii-Flush-Type', 'fastcgi_finish_request', true); $this->getResponse()->done(); call_user_func_array($i1, $i); Tii_Config::isDebugMode() || fastcgi_finish_request(); } else { $this->getResponse()->setHeader('Tii-Flush-Type', 'normal', true); $this->getResponse()->done(); call_user_func_array($i1, $i); ob_flush(); flush(); } } public function setActionName($i) { parent::setActionName($i); $this->setRender($i); } public function forward($i = NULL, $i1 = NULL, $i2 = NULL) { $this->noRender(); return parent::forward($i, $i1, $i2); } public function redirect($i, $i1 = 0) { $this->noRender(); $i = str_replace(["\n", "\r"], '', $i); if (!$this->getResponse()->isResponsed()) { if ($i1 === 0) { $this->getResponse()->setHeader('Location', $i)->done(); } else { $this->getResponse()->setHeader('Refresh', $i1 . ";url=" .$i)->done(); } } else { print("<meta http-equiv='Refresh' content='" . $i1 . ";URL=" .$i. "'>"); } exit; } public function url($i = NULL, $i1 = NULL, array $i2 = [], $i3 = '/', $i4 = '.html') { $i || $i = []; if (is_string($i)) { if (($i5 = strrpos($i, '.')) !== false) { $i4 = substr($i, $i5); $i = substr($i, 0, $i5); } $i6 = explode("/", $i); $i = []; $i['module'] = Tii::valueInArray($i6, 1, $this->getDefaultModuleName()); $i['controller'] = Tii::valueInArray($i6, 2, $this->getDefaultControllerName()); $i['action'] = Tii::valueInArray($i6, 3, $this->getDefaultActionName()); } $i = array_merge([ 'module' => $this->getModuleName(), 'controller' => $this->getControllerName(), 'action' => $this->getActionName(), ], $i ); $i7 = []; if (empty($i2)) { if ($i['action'] != $this->getDefaultActionName()) { $i7[] = $i['module']; $i7[] = $i['controller']; $i7[] = $i['action']; } else { if ($i['controller'] != $this->getDefaultControllerName()) { $i7[] = $i['module']; $i7[] = $i['controller']; } else { $i7[] = $i['module']; } } } else { $i7[] = $i['module']; $i7[] = $i['controller']; $i7[] = $i['action']; foreach($i2 as $i8 => $i9) { $i7[] = $i8; $i7[] = $i9; } } if ($i7 = implode('/', $i7)) $i7 .= $i4; return Tii_Event::filter('tii.application.processor.http.url', Tii_Http::urlAppend($i3 . $i7, $i1)); } protected function urlParser() { $i = parse_url($this->getRequestUri()); isset($i['path']) || $i['path'] = '/'; if (preg_match('|(.*)\.(\w+)$|', $i['path'], $i1)) { $i['path'] = $i1[1]; $this->viewFormat = $i1[2]; } $i2 = explode('/', trim($i['path'], '/')); isset($i2[0]) && $this->setModuleName($i2[0]); isset($i2[1]) && $this->setControllerName($i2[1]); isset($i2[2]) && $this->setActionName($i2[2]); $i3 = []; for ($i4 = 3, $i5 = count($i2); $i4 < $i5; $i4 = $i4 + 2) { $i3[$i2[$i4]] = (isset($i2[$i4+1])) ? $i2[$i4+1] : ''; } $this->setPairs($i3); $this->requestPath = $i['path']; if (isset($i['query'])) { $_SERVER['QUERY_STRING'] = $i['query']; parse_str($i['query'], $i6); foreach ($i6 as $i7 => $i8) { $_GET[$i7] = $i8; $_REQUEST[$i7] = $i8; } } } }
 class Tii_Worker_Protocol extends Tii_ConfigWrapper { public function __call($i, $i1) { try { if (empty($this->{$i})) return NULL; return call_user_func_array($this->{$i}, $i1); } catch (Exception $i2) { Tii_Logger::debug(get_called_class() . " call `$i' error: " . $i2->getMessage(), $i1); exit(250); } } }
 class Tii_Application_Processor_Http_Render extends Tii_Application_Abstract { public function includer($__file_) { extract((array)$this->getView()); include $__file_; } public function layout($i, $i1 = NULL) { $this->includer(Tii::filename('views', $i1 ?: $this->getModuleName(), $i, 'phtml', "layouts")); } public function fragment($i, $i1 = NULL) { $this->includer(Tii::filename('views', $i1 ?: $this->getModuleName(), $i, 'phtml', "fragments")); } public function render($i, $i1 = NULL, $i2 = NULL) { $i2 || $i2 = $this->getModuleName(); $i1 || $i1 = $this->getControllerName(); include Tii::filename('views', $i2, $i, 'phtml', "scripts/$i1"); } public function display($i = 0) { $i1 = $this->getModuleName(); $i2 = $this->getControllerName(); $i3 = (array)$this->getView(); $i4 = Tii::filename('views', $i1, $this->getRender(), 'phtml', "scripts/$i2"); $i5 = $this->getLayout(); $this->noLayout(); $this->noRender(); if (!$i5) { if (!$i) return $this->renderFile($i4, $i3); echo $i6 = $this->renderFile($i4, $i3, true); return $this->cachingViewData($i, $i6); } $i7 = $this->renderFile($i4, $i3, true); $i3 = array_merge($i3, ['_viewer_' => $i7]); if (($i8 = strstr($i5, '/', true)) !== false) { $i1 = $i8; $i5 = substr($i5, strlen($i8)+1); } unset($i8); $i9 = Tii::filename('views', $i1, $i5, 'phtml', "layouts"); if (!is_file($i9)) { $i9 = Tii::filename('views', "default", $i5, 'phtml', "layouts"); } if (!$i) return $this->renderFile($i9, $i3); echo $i6 = $this->renderFile($i9, $i3, true); return $this->cachingViewData($i, $i6); } protected function renderFile($__file_, $__viewer_ = [], $__return_ = false) { if (empty($__file_) || !is_file($__file_)) { throw new Tii_Application_Exception("render file '%s` not exist", $__file_); } $_viewer = &$__viewer_; extract((array)$_viewer); if ($__return_) { ob_start(); ob_implicit_flush(false); require $__file_; return ob_get_clean(); } require $__file_; } }
 class Tii_Worker_Client { public static $clients = []; public $id; protected $socket; protected $remote_socket; protected $timeout; protected $protocol; protected $type = 'text'; public $onConnect; public $onMessage; public $onClose; public $onError; public static function broadcast($i, $i1, $i2 = false) { $socket = stream_socket_client($i, $i3, $i4); if (!$socket) { if ($i2) throw new Tii_Exception($i4); Tii_Logger::debug("broadcast $i error: $i4", func_num_args()); return false; } return stream_socket_sendto($socket, $i1) == strlen($i1); } public function __construct($i, $timeout = 5) { $this->id = spl_object_hash($this); self::$clients[$this->id] = $this; list($i1, $i2) = explode(':', $i, 2); $i3 = Tii_Worker::$init['builtin_transports']; $i4 = 'tcp'; if (!isset($i3[$i1])) { $i5 = $this->getProtocols(); if (!isset($i5[$i1])) { throw new Exception("Protocol `$i1' not exist"); } $this->protocol = new Tii_Worker_Protocol($i5[$i1]); list($this->type) = explode('.', $i1, 2); } else { $i4 = $i3[$i1]; } $this->remote_socket = "{$i4}:{$i2}"; $this->timeout = $timeout ?: ini_get("default_socket_timeout"); } protected function getProtocols() { static $i; $i || $i = Tii_Event::filter('tii.worker.protocols', Tii::valueInArray( array_replace_recursive(Tii_Worker::$init, Tii::get('tii.worker', [])), 'protocols', [] ) ); return $i; } public function assert() { $socket = stream_socket_client($this->remote_socket, $i, $i1, $this->timeout); if (!$socket) { throw new Tii_Exception($i1); } $this->socket = $socket; return true; } public function getSocket() { is_resource($this->socket) || $this->connect(); return $this->socket; } public function connect() { $this->assert(); stream_set_blocking($this->socket, true); list($i, $i1) = explode('.', $this->timeout . '.'); stream_set_timeout($this->socket, intval($i), intval($i1)); if ($this->onConnect) call_user_func($this->onConnect, $this, $this->receive()); } public static function run($timeout = 0, $i = NULL) { $i1 = new Tii_Timer(); $i1->addPeriodic(function() { foreach(self::$clients as $id => $i2) { try { while(!in_array(($i3 = $i2->receive()), ['', NULL])) { if ($i2->onMessage) call_user_func($i2->onMessage, $i2, $i3); } } catch (Exception $i4) { if ($i2->onError) call_user_func($i2->onError, $i2, $i4->getMessage()); } } }); $i1->addPeriodic(function() {sleep(1);}); if (is_callable($i)) call_user_func($i, $i1); $i1->run($timeout); } public function request($i = '') { if (!$this->send($i)) throw new Tii_Exception('send via [%s] chunk failed', $this->remote_socket); return $this->receive(); } public function receive() { return call_user_func([$this, $this->type]); } protected function send($i, $i1 = 3, $i2 = false) { if ($this->protocol && !$i2) { $i = $this->protocol->encode($i); } if (fwrite($this->getSocket(), $i) === strlen($i)) { return true; } else { $this->connect(); if ($i1) return $this->send($i, --$i1, true); return false; } } protected function chunk($i = 3, $i1 = 4, $i2 = 8192) { $i3 = ''; $i4 = false; $socket = $this->getSocket(); while(1) { $i5 = fread($socket, $i2); if ($i5 === '') return NULL; if ($i5 === false) { $this->connect(); if ($i) return $this->chunk(--$i, $i1, $i2); throw new Tii_Exception('failed to get data from %s by chunk', $this->remote_socket); } $i3 .= $i5; $i6 = strlen($i3); if ($i6 >= $i1) { if ($i4) break; $i7 = unpack('Ntotal_length', $i3); $i1 = $i7['total_length']; if ($i6 >= $i1) break; $i4 = true; } } if ($this->protocol) { $i3 = $this->protocol->decode($i3); } return $i3; } protected function text($i = 3, $i1 = 1024) { $i2 = ''; $socket = $this->getSocket(); while (1) { $i3 = fgets($socket, 1024); if ($i3 === '') return NULL; if ($i3 === false) { $this->connect(); if ($i) return $this->text(--$i, $i1); throw new Tii_Exception('failed to get data from %s by text', $this->remote_socket); } $i2 .= $i3; if (strpos($i2, "\n") !== false) { break; } } $i2 = trim($i2); if ($this->protocol) { $i2 = $this->protocol->decode($i2); } return $i2; } public function close() { if (is_resource($this->socket)) @fclose($this->socket); $this->socket = NULL; if ($this->onClose) call_user_func($this->onClose); } public function __destruct() { $this->close(); } }
 class Tii_Cache { private $classNames = []; public function __construct() { call_user_func_array([$this, 'setChain'], Tii::get('tii.cache.chain', ['memcache', 'apc', 'file'])); } public function setChain() { foreach(array_unique(func_get_args()) as $i) { if ($i{0} == '@') { $this->classNames[] = substr($i, 1); } else { $this->classNames[] = Tii::className('Tii', 'Cache', $i); } } return $this; } public function cached($i, $i1 = 0, $i2 = NULL, array $i3 = [], $i4 = 5) { try { return call_user_func_array([$this, '_cached'], func_get_args()); } catch (Exception $i5) { Tii_Logger::warn("cache `$i' exception:". $i5->getMessage()); return Tii::call($i2, $i3); } } private function _cached($i, $i1 = 0, $i2 = NULL, array $i3 = [], $i4 = 5) { if ($i1 < 0) { $this->delete($i); return Tii::call($i2, $i3); } $i5 = $this->get($i); $i6 = isset($i5['data']); if ($i6 && (($i5['expired'] - time()) < 15)) { Tii_Filesystem::locker($i . '.expired.lock', function() use (&$i6) { $i6 = false; }); } if ($i6) return $i5['data']; Tii_Filesystem::locker($i . '.cached.lock', function() use (&$i5, $i, $i2, $i3, $i1) { ignore_user_abort(true); $i5 = [ 'data' => Tii::call($i2, $i3), 'expired' => time() + $i1, ]; $this->set($i, $i5, 0, $i1); ignore_user_abort(false); }, function() use (&$i5, $i, $i1, $i2, $i3, $i4){ if ($i4--) { usleep(round(rand(10, 100) * 1000 * $i4)); $i5 = $this->cached($i, $i1, $i2, $i3, $i4); } } ); return Tii::valueInArray($i5, 'data'); } public function __call($i, $i1) { foreach($this->classNames as $i2) { $i3 = Tii::object($i2); if (($i3 instanceof Tii_Cache_Abstract) && $i3->isSupported()) { return call_user_func_array([$i3, $i], $i1); } } throw new Tii_Exception("effective cache in chain %s not found", json_encode($this->classNames)); } }
 class Tii_Worker extends Tii_Worker_Callable { const E_CONNECT_FAIL = 1; const E_SEND_FAIL = 2; const STATUS_STARTING = 1; const STATUS_RUNNING = 2; const STATUS_SHUTDOWN = 4; const STATUS_RELOADING = 8; public $id = 0; public $connections = []; public $host; public $dsn; protected $protocol = null; protected $socket = null; protected $socketName = ''; protected $context = null; protected $name = 'none'; protected $runtime = []; public static $init = [ 'count' => 1, 'transport' => 'tcp', 'protocol ' => '', 'reloadable' => true, 'reusePort' => false, 'default_backlog' => 1024, 'max_udp_package_size' => 65535, 'name' => 'none', 'user' => '', 'group' => '', 'available_events' => [ 'libevent', 'event', 'ev' ], 'default_event' => 'select', 'builtin_transports' => [ 'tcp' => 'tcp', 'udp' => 'udp', 'unix' => 'unix', 'ssl' => 'tcp', 'sslv2' => 'tcp', 'sslv3' => 'tcp', 'tls' => 'tcp' ], 'connection' => [ 'read_buffer_size' => 65535, 'max_send_buffer_size' => 1048576, 'default_max_send_buffer_size' => 1048576, 'max_package_size' => 10485760, ], ]; public static $globalStart = false; public static $startFile = ''; public static $delayKillingTime = 2; public static $daemonize = false; public static $events = null; public static $stdoutFile = '/dev/null'; protected static $status = self::STATUS_STARTING; protected static $pid = 0; protected static $pids = []; protected static $pidsToRestart = []; protected static $ids = []; protected static $workers = []; protected static $pidFile = ''; protected static $statusFile = ''; protected static $statistics = [ 'start_timestamp' => 0, 'worker_exit_info' => [], ]; public $onWorkerStart; public $onWorkerReload; public $onWorkerStop; public $onConnect; public $onMessage; public $onClose; public $onBufferFull; public $onBufferDrain; public $onError; public function __get($name) { return Tii::valueInArray($this->runtime, $name); } public function __construct($name = '', $runtime = [], $i = [], $host = NULL) { $this->id = spl_object_hash($this); self::$workers[$this->id] = $this; self::$pids[$this->id] = []; $this->runtime = array_replace_recursive(self::$init, Tii::get('tii.worker', []), $runtime); $this->name = $this->runtime['name']; $this->host = $host ?: Tii_Network::getIp(); if ($name) { $this->socketName = $name; if (!isset($i1['socket']['backlog'])) { $i1['socket']['backlog'] = Tii::valueInArray($this->runtime, 'default_backlog', 1204); } $this->context = stream_context_create($i); $this->dsn = str_replace('0.0.0.0', $this->host, $name); } } public function getProtocols() { return Tii_Event::filter('tii.worker.protocols', Tii::valueInArray($this->runtime, 'protocols', [])); } public function getSocketName() { return $this->socketName; } public static function run() { if (PHP_SAPI != "cli") { exit("only run in command line mode \n"); } if (!function_exists('pcntl_signal')) { throw new Tii_Exception('require pcntl extension loaded'); } $i = debug_backtrace(); self::$startFile || self::$startFile = $i[count($i) - 1]['file']; self::$pidFile || self::$pidFile = Tii_Filesystem::hashfile( self::$startFile, 'worker', ".pid", Tii_Filesystem::getDataDir() ); self::$status = self::STATUS_STARTING; self::$statistics['start_timestamp'] = time(); self::$statusFile = Tii_Filesystem::hashfile(self::$startFile, 'worker', ".status"); self::setProcessTitle('Worker: master process  start_file=' . self::$startFile); Tii::usage(); if (Tii::get('tii.timezone')) { Tii_Time::timezone(Tii::get('tii.timezone')); } Tii_Event::init(); foreach (self::$workers as $i1 => $i2) { self::$ids[$i1] = array_fill(0, $i2->count, 0); } Tii_Worker_Timer::init(); self::parseCommand(); self::daemonize(); self::initWorkers(); self::installSignal(); self::saveMasterPid(); self::forks(); self::dashboard(); self::resetStd(); self::monitorWorkers(); } public static function runAll($name = NULL) { self::$globalStart = true; if ($name) self::$startFile = $name; foreach(Tii::get('tii.worker.loader.classes', []) as $i) { call_user_func([$i, 'run']); } foreach(Tii::get('tii.worker.loader.files', []) as $i1) { require_once $i1; } self::run(); } protected static function collectingStatusData() { $i = ['name' => 11, 'socketName' => 9]; $workers = self::$workers; array_walk($workers, function($i1) use (&$i){ foreach($i as $i2 => $i3) { $i4 = strlen($i1->{$i2}); $i[$i2] = $i4 > $i3 ? $i4 : $i3; } }); array_walk($i, function(&$i5) { $i5 = $i5+2; }); if (self::$pid === posix_getpid()) { $i6 = Tii::usage(); file_put_contents(self::$statusFile, str_pad('GLOBAL STATUS', 100, "-", STR_PAD_BOTH) . "\n"); file_put_contents(self::$statusFile, 'Tii version:' . Tii_Version::VERSION . "          PHP version:" . PHP_VERSION . "\n", FILE_APPEND); file_put_contents(self::$statusFile, 'start time:' . Tii_Time::format('Y-m-d H:i:s', $i6->initialTime) . '   run ' . floor($i6->totalConsumedTime / (24 * 60 * 60)) . ' days ' . floor(($i6->totalConsumedTime % (24 * 60 * 60)) / (60 * 60)) . " hours   \n", FILE_APPEND); $i7 = 'load average: ' . implode(", ", $i6->loadavg); file_put_contents(self::$statusFile, str_pad($i7, 33) . ' event-loop:' . Tii_Worker_Event::getDriverName() . "\n", FILE_APPEND); file_put_contents(self::$statusFile, count(self::$pids) . ' workers       ' . count(self::getAllPids()) . " processes\n", FILE_APPEND); file_put_contents(self::$statusFile, str_pad('worker_name', $i['name']) . " exit_status     exit_count\n", FILE_APPEND); foreach (self::$pids as $i8 => $i9) { $i1 = self::$workers[$i8]; if (isset(self::$statistics['worker_exit_info'][$i8])) { foreach (self::$statistics['worker_exit_info'][$i8] as $iA => $iB) { file_put_contents(self::$statusFile, str_pad($i1->name, $i['name']) . " " . str_pad($iA, 16) . " $iB\n", FILE_APPEND); } } else { file_put_contents(self::$statusFile, str_pad($i1->name, $i['name']) . " " . str_pad(0, 16) . " 0\n", FILE_APPEND); } } file_put_contents(self::$statusFile, str_pad('PROCESS STATUS', 100, "-", STR_PAD_BOTH) . "\n", FILE_APPEND); file_put_contents(self::$statusFile, "pid\tmemory  " . str_pad('listening', $i['socketName']) . " " . str_pad('worker_name', $i['name']) . " connections " . str_pad('total_request', 13) . " " . str_pad('send_fail', 9) . " " . str_pad('throw_exception', 15) . "\n", FILE_APPEND); chmod(self::$statusFile, 0722); foreach (self::getAllPids() as $iC) { posix_kill($iC, SIGUSR2); } return; } $i1 = current(self::$workers); $iD = posix_getpid() . "\t" . str_pad(Tii_Filesystem::format(memory_get_usage(true)), 7) . " " . str_pad($i1->socketName, $i['socketName']) . "" . str_pad(($i1->name === $i1->socketName ? 'none' : $i1->name), $i['name']) . ""; $iD .= str_pad(Tii_Worker_Connection::$statistics['connection_count'], 11) . " " . str_pad(Tii_Worker_Connection::$statistics['total_request'], 14) . " " . str_pad(Tii_Worker_Connection::$statistics['send_fail'], 9) . " " . str_pad(Tii_Worker_Connection::$statistics['throw_exception'], 15) . "\n"; file_put_contents(self::$statusFile, $iD, FILE_APPEND); } protected static function monitorWorkers() { self::$status = self::STATUS_RUNNING; while (1) { pcntl_signal_dispatch(); $status = 0; $pid = pcntl_wait($status, WUNTRACED); pcntl_signal_dispatch(); if ($pid > 0) { foreach (self::$pids as $i => $i1) { if (isset($i1[$pid])) { $i2 = self::$workers[$i]; if ($status !== 0) { Tii_Logger::debug("worker[" . $i2->name . ":$pid] exit with status $status"); } if (!isset(self::$statistics['worker_exit_info'][$i][$status])) { self::$statistics['worker_exit_info'][$i][$status] = 0; } self::$statistics['worker_exit_info'][$i][$status]++; unset(self::$pids[$i][$pid]); $id = self::getId($i, $pid); self::$ids[$i][$id] = 0; break; } } if (self::$status !== self::STATUS_SHUTDOWN) { self::forks(); if (isset(self::$pidsToRestart[$pid])) { unset(self::$pidsToRestart[$pid]); self::reload(); } } else { if (!self::getAllPids()) { self::exitAndClearAll(); } } } else { if (self::$status === self::STATUS_SHUTDOWN && !self::getAllPids()) { self::exitAndClearAll(); } } } } protected static function exitAndClearAll() { foreach (self::$workers as $i) { $i1 = $i->socketName; if ($i->transport === 'unix' && $i1) { list(, $i2) = explode(':', $i1, 2); @unlink($i2); } } @unlink(self::$pidFile); Tii_Logger::debug("Worker[" . basename(self::$startFile) . "] has been stopped"); exit(0); } protected static function dashboard() { $i = ['user' => 4, 'name' => 6, 'socketName' => 6, 'count' => 9, 'status' => 6]; $workers = self::$workers; array_walk($workers, function($i1) use (&$i){ foreach($i as $i2 => $i3) { $i4 = strlen($i1->{$i2}); $i[$i2] = $i4 > $i3 ? $i4 : $i3; } }); $i5 = 0; array_walk($i, function(&$i6, $i7) use (&$i5) { if ($i7 != 'status') $i6 = $i6+2; $i5 += $i6; }); $i8 = ' TII WORKER '; $i3 = floor(($i5 - strlen($i8)) / 2); printf("\033[1A\n\033[K".str_pad("", $i3, '-')."\033[47;30m$i8\033[0m".str_pad("", $i3, '-')."\n\033[0m"); echo 'Tii version:', Tii_Version::VERSION, "          PHP version:", PHP_VERSION, "\n"; $i8 = ' WORKERS '; $i3 = floor(($i5 - strlen($i8)) / 2); echo str_pad("", $i3, '-')."\033[47;30m$i8\033[0m".str_pad("", $i3, '-')."\n"; $i9 = sprintf("%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds\n", $i['user'], $i['name'], $i['socketName'], $i['count'], $i['status'] ); echo preg_replace('|\[([^ ]+)( *)\]|U', "\033[47;30m$1\033[0m$2", sprintf(preg_replace('|(%-\d+s)|U', "[$1]", $i9), 'user', 'worker', 'listen', 'processes', 'status')); foreach ($workers as $i1) { printf($i9, $i1->user, $i1->name, $i1->socketName, $i1->count, "\033[32;40m [OK] \033[0m"); } echo str_pad("\n", $i5, '-', STR_PAD_LEFT); if (self::$daemonize) { global $argv; $iA = $argv[0]; echo "Input \"php $iA stop\" to quit. Start success.\n"; } else { echo "Press Ctrl-C to quit. Start success.\n"; } } protected static function forks() { foreach (self::$workers as $i) { if (self::$status === self::STATUS_STARTING) { if (empty($i->name)) { $i->name = $i->socketName; } } while (count(self::$pids[$i->id]) < $i->count) { static::fork($i); } } } protected static function fork($i) { $pid = pcntl_fork(); $id = self::getId($i->id, 0); if ($pid > 0) { self::$pids[$i->id][$pid] = $pid; self::$ids[$i->id][$id] = $pid; } elseif (0 === $pid) { if ($i->reusePort) { $i->listen(); } if (self::$status === self::STATUS_STARTING) { self::resetStd(); } self::$pids = []; self::$workers = [$i->id => $i]; Tii_Worker_Timer::delAll(); self::setProcessTitle('Worker: worker process  ' . $i->name . ' ' . $i->socketName); $i->setUserAndGroup(); $i->id = $id; $i->start(); exit(250); } else { throw new Exception("fork failed"); } } protected static function resetStd() { if (!self::$daemonize) { return; } global $i, $i1; $i2 = fopen(self::$stdoutFile, "a"); if ($i2) { unset($i2); @fclose(STDOUT); @fclose(STDERR); $i = fopen(self::$stdoutFile, "a"); $i1 = fopen(self::$stdoutFile, "a"); } else { throw new Exception('can not open stdoutFile ' . self::$stdoutFile); } } protected static function getId($i, $pid) { $id = array_search($pid, self::$ids[$i]); if ($id === false) { echo "getId fail\n"; } return $id; } public function setUserAndGroup() { $i = posix_getpwnam($this->user); if (!$i) { Tii_Logger::debug("Warning: User {$this->user} not exsits"); return; } $i1 = $i['uid']; if ($this->group) { $i2 = posix_getgrnam($this->group); if (!$i2) { Tii_Logger::debug("Warning: Group {$this->group} not exsits"); return; } $i3 = $i2['gid']; } else { $i3 = $i['gid']; } if ($i1 != posix_getuid() || $i3 != posix_getgid()) { if (!posix_setgid($i3) || !posix_initgroups($i['name'], $i3) || !posix_setuid($i1)) { Tii_Logger::debug("Warning: change gid or uid fail."); } } } protected static function saveMasterPid() { self::$pid = posix_getpid(); if (false === @file_put_contents(self::$pidFile, self::$pid)) { throw new Exception('can not save pid to ' . self::$pidFile); } } protected static function initWorkers() { foreach (self::$workers as $i) { if (empty($i->name)) { $i->name = 'none'; } if (empty($i->user)) { $i->user = self::getCurrentUser(); } else { if (posix_getuid() !== 0 && $i->user != self::getCurrentUser()) { Tii_Logger::debug('Warning: You must have the root privileges to change uid and gid.'); } } if (!$i->reusePort) { $i->listen(); } } } public function listen() { if (!$this->socketName || $this->socket) { return; } $i = $this->socketName; list($i1, $i2) = explode(':', $this->socketName, 2); if (!isset($this->builtin_transports[$i1])) { $i3 = $this->getProtocols(); if (!isset($i3[$i1])) { throw new Exception("Protocol $i1 not exist"); } $this->protocol = new Tii_Worker_Protocol($i3[$i1]); $i = $this->transport . ":" . $i2; } else { $this->transport = $this->builtin_transports[$i1]; } $i4 = $this->transport === 'udp' ? STREAM_SERVER_BIND : STREAM_SERVER_BIND | STREAM_SERVER_LISTEN; $i5 = 0; $i6 = ''; if ($this->reusePort) { stream_context_set_option($this->context, 'socket', 'so_reuseport', 1); } if ($this->transport === 'unix') { umask(0); list(, $i2) = explode(':', $this->socketName, 2); if (!is_file($i2)) { register_shutdown_function(function () use ($i2) { @unlink($i2); }); } } $this->socket = stream_socket_server($i, $i5, $i6, $i4, $this->context); if (!$this->socket) { throw new Exception($i6); } if (function_exists('socket_import_stream') && $this->transport === 'tcp') { $socket = socket_import_stream($this->socket); @socket_set_option($socket, SOL_SOCKET, SO_KEEPALIVE, 1); @socket_set_option($socket, SOL_TCP, TCP_NODELAY, 1); } stream_set_blocking($this->socket, 0); if (self::$events) { if ($this->transport === 'udp') { self::$events->add($this->socket, Tii_Worker_Event::EV_READ, [$this, 'acceptUdpConnection']); } else { self::$events->add($this->socket, Tii_Worker_Event::EV_READ, [$this, 'acceptConnection']); } } } protected static function getCurrentUser() { $i = posix_getpwuid(posix_getuid()); return $i['name']; } protected static function setProcessTitle($i) { if (function_exists('cli_set_process_title')) { @cli_set_process_title($i); } elseif (extension_loaded('proctitle') && function_exists('setproctitle')) { @setproctitle($i); } } protected static function parseCommand() { global $argv; $i = $argv[0]; if (!isset($argv[1])) { exit("Usage: php yourfile.php {start|stop|restart|reload|status|kill}\n"); } $i1 = trim($argv[1]); $i2 = isset($argv[2]) ? $argv[2] : ''; $i3 = ''; if ($i1 === 'start') { if ($i2 === '-d' || self::$daemonize) { $i3 = 'in DAEMON mode'; } else { $i3 = 'in DEBUG mode'; } } Tii_Logger::debug("Worker[$i] $i1 $i3"); $i4 = @file_get_contents(self::$pidFile); $i5 = $i4 && @posix_kill($i4, 0); if ($i5) { if ($i1 === 'start') { Tii_Logger::debug("Worker[$i] already running"); exit; } } elseif ($i1 !== 'start' && $i1 !== 'restart' && $i1 !== 'kill') { Tii_Logger::debug("Worker[$i] not run"); exit; } switch ($i1) { case 'kill': exec("ps aux | grep $i | grep -v grep | awk '{print $2}' |xargs kill -SIGINT"); usleep(100000); exec("ps aux | grep $i | grep -v grep | awk '{print $2}' |xargs kill -SIGKILL"); break; case 'start': if ($i2 === '-d') { self::$daemonize = true; } break; case 'status': if (is_file(self::$statusFile)) { @unlink(self::$statusFile); } posix_kill($i4, SIGUSR2); usleep(100000); echo $status = file_get_contents(self::$statusFile); preg_match_all('|\d+\s+([\d.]+[a-z]{1,2})\s+.*\s+.*\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)|iUs', $status, $i6); if (isset($i6[5])) { $i6[1] = array_map(function($i7){return Tii_Filesystem::bytes($i7);}, $i6[1]); printf("%s\ntotal: %s memory, %d connections, %d requests, %d send_fails, %d throw_exceptions\n", str_pad("", 100, "-", STR_PAD_BOTH), Tii_Filesystem::format(array_sum($i6[1])), array_sum($i6[2]), array_sum($i6[3]), array_sum($i6[4]), array_sum($i6[5]) ); } exit(0); case 'restart': case 'stop': Tii_Logger::debug("Worker[$i] is stopping ..."); $i4 && posix_kill($i4, SIGINT); $i8 = 5; $i9 = time(); while (1) { $i5 = $i4 && posix_kill($i4, 0); if ($i5) { if (time() - $i9 >= $i8) { Tii_Logger::debug("Worker[$i] stop fail"); exit; } usleep(10000); continue; } Tii_Logger::debug("Worker[$i] stop success"); if ($i1 === 'stop') { exit(0); } if ($i2 === '-d') { self::$daemonize = true; } break; } break; case 'reload': posix_kill($i4, SIGUSR1); Tii_Logger::debug("Worker[$i] reload"); exit; default : exit("Usage: php yourfile.php {start|stop|restart|reload|status|kill}\n"); } } protected static function installSignal() { pcntl_signal(SIGINT, ['Tii_Worker', 'signalHandler'], false); pcntl_signal(SIGUSR1, ['Tii_Worker', 'signalHandler'], false); pcntl_signal(SIGUSR2, ['Tii_Worker', 'signalHandler'], false); pcntl_signal(SIGPIPE, SIG_IGN, false); } protected static function reinstallSignal() { pcntl_signal(SIGINT, SIG_IGN, false); pcntl_signal(SIGUSR1, SIG_IGN, false); pcntl_signal(SIGUSR2, SIG_IGN, false); self::$events->add(SIGINT, Tii_Worker_Event::EV_SIGNAL, ['Tii_Worker', 'signalHandler']); self::$events->add(SIGUSR1, Tii_Worker_Event::EV_SIGNAL, ['Tii_Worker', 'signalHandler']); self::$events->add(SIGUSR2, Tii_Worker_Event::EV_SIGNAL, ['Tii_Worker', 'signalHandler']); } public static function signalHandler($i) { switch ($i) { case SIGINT: self::quit(); break; case SIGUSR1: self::$pidsToRestart = self::getAllPids(); self::reload(); break; case SIGUSR2: self::collectingStatusData(); break; } } protected static function daemonize() { if (!self::$daemonize) { Tii_Logger::$print = true; return; } umask(0); $pid = pcntl_fork(); if (-1 === $pid) { throw new Exception('fork failed'); } elseif ($pid > 0) { exit(0); } if (-1 === posix_setsid()) { throw new Exception("setsid failed"); } $pid = pcntl_fork(); if (-1 === $pid) { throw new Exception("fork failed"); } elseif (0 !== $pid) { exit(0); } } protected static function getAllPids() { $pids = []; foreach (self::$pids as $i) { foreach ($i as $pid) { $pids[$pid] = $pid; } } return $pids; } protected static function reload() { if (self::$pid === posix_getpid()) { if (!in_array(self::$status, [self::STATUS_RELOADING, self::STATUS_SHUTDOWN])) { Tii_Logger::debug("Worker[" . basename(self::$startFile) . "] reloading"); self::$status = self::STATUS_RELOADING; } $i = []; foreach (self::$pids as $id => $pids) { $i1 = self::$workers[$id]; if ($i1->reloadable) { foreach ($pids as $pid) { $i[$pid] = $pid; } } else { foreach ($pids as $pid) { posix_kill($pid, SIGUSR1); } } } self::$pidsToRestart = array_intersect(self::$pidsToRestart, $i); if (empty(self::$pidsToRestart)) { if (self::$status !== self::STATUS_SHUTDOWN) { self::$status = self::STATUS_RUNNING; } return; } $pid = current(self::$pidsToRestart); posix_kill($pid, SIGUSR1); Tii_Worker_Timer::add(self::$delayKillingTime, 'posix_kill', [$pid, SIGKILL], false); } else { $i1 = current(self::$workers); $i1->onWorkerReload(); if ($i1->reloadable) { self::quit(); } } } public static function quit() { self::$status = self::STATUS_SHUTDOWN; if (self::$pid === posix_getpid()) { Tii_Logger::debug("Worker[" . basename(self::$startFile) . "] Stopping ..."); foreach (self::getAllPids() as $pid) { posix_kill($pid, SIGINT); Tii_Worker_Timer::add(self::$delayKillingTime, 'posix_kill', [$pid, SIGKILL], false); } } else { foreach (self::$workers as $i) { $i->stop(); } exit(0); } } public function stop() { $this->onWorkerStop(); self::$events->delete($this->socket, Tii_Worker_Event::EV_READ); if ($this->socket) @fclose($this->socket); } public function start() { self::$status = self::STATUS_RUNNING; if (!self::$events) { self::$events = Tii_Worker_Event::instance(); if ($this->socketName) { if ($this->transport !== 'udp') { self::$events->add($this->socket, Tii_Worker_Event::EV_READ, [$this, 'acceptConnection']); } else { self::$events->add($this->socket, Tii_Worker_Event::EV_READ, [$this, 'acceptUdpConnection']); } } } self::reinstallSignal(); Tii_Worker_Timer::init(self::$events); $this->onWorkerStart(); self::$events->loop(); } public function acceptConnection($socket) { $i = @stream_socket_accept($socket, 0, $i1); if (!$i) return; $i2 = new Tii_Worker_Connection_Tcp($i, $i1); $this->connections[$i2->id] = $i2; $i2->worker = $this; $i2->protocol = $this->protocol; $i2->onConnect = $this->onConnect; $i2->onMessage = $this->onMessage; $i2->onClose = $this->onClose; $i2->onBufferFull = $this->onBufferFull; $i2->onBufferDrain = $this->onBufferDrain; $i2->onError = $this->onError; $i2->onConnect(); } public function acceptUdpConnection($socket) { $i = stream_socket_recvfrom($socket, $this->max_udp_package_size, 0, $i1); if (false === $i || empty($i1)) return false; $i2 = new Tii_Worker_Connection_Udp($socket, $i1); $i2->protocol = $this->protocol; $i2->onMessage = $this->onMessage; if ($this->onMessage) { if ($this->protocol) { $i = $this->protocol->decode($i, $i2); if ($i === false) return true; } Tii_Worker_Connection::$statistics['total_request']++; $i2->onMessage($i); } return true; } } Tii_Event::register('tii.worker.protocols', function($i) { $i['text'] = [ 'input' => function($i1, $i2) { if (strlen($i1) >= $i2->maxPackageSize) { $i2->close(); return 0; } $i3 = strpos($i1, "\n"); return $i3 === false ? 0 : $i3 + 1; }, 'encode' => function($i1) { return $i1 . "\n"; }, 'decode' => function($i1) { return trim($i1); }, ]; $i['chunk'] = [ 'input' => function($i1) { if (strlen($i1) < 4) return 0; $i4 = unpack('Ntotal_length', $i1); return $i4['total_length']; }, 'encode' => function($i1) { return pack('N', 4 + strlen($i1)) . $i1; }, 'decode' => function($i1) { return substr($i1, 4); } ]; $i["chunk.gz"] = [ 'input' => $i['chunk']['input'], 'encode' => function($i1) use ($i) { return call_user_func($i['chunk']['encode'], gzcompress($i1)); }, 'decode' => function($i1) use ($i) { return gzuncompress(call_user_func($i['chunk']['decode'], $i1)); } ]; foreach(Tii_Event::filter('tii.worker.protocols.extra', ['text', 'chunk', "chunk.gz"]) as $i5) { $i["$i5.serialize"] = [ 'input' => $i[$i5]['input'], 'encode' => function($i1) use ($i, $i5) { return call_user_func($i[$i5]['encode'], serialize($i1)); }, 'decode' => function($i1) use ($i, $i5) { return unserialize(call_user_func($i[$i5]['decode'], $i1)); } ]; $i["$i5.json"] = [ 'input' => $i[$i5]['input'], 'encode' => function($i1) use ($i, $i5) { return call_user_func($i[$i5]['encode'], json_encode($i1)); }, 'decode' => function($i1) use ($i, $i5) { return json_decode(call_user_func($i[$i5]['decode'], $i1), true); } ]; } return $i; });
 final class Tii_Dao_Connection { private $connection; private $config = [ 'dsn' => [ 'host' => 'localhost', 'port' => 3306, 'dbname'=> 'test', ], 'attr' => [ PDO::ATTR_PERSISTENT => true, ], 'charset' => 'UTF8', 'username' => 'root', 'passwd' => '', ]; private $lastHeartbeatTime = 0; public function __construct($config = NULL) { if (is_array($config)) { $this->config = array_merge($this->config, $config); } } public function getConnection() { $this->lastHeartbeatTime || $this->lastHeartbeatTime = time(); if ($this->connection && (time() - $this->lastHeartbeatTime > 120)) { $this->lastHeartbeatTime = time(); $this->connection = NULL; } if (!$this->connection) { $i = []; foreach ($this->config['dsn'] as $i1 => $i2) { $i[] = $i1 . '=' . $i2; } $i = 'mysql:' . implode(';', $i); $this->connection = new Tii_Dao_Common_PropelPDO($i, $this->config['username'], $this->config['passwd']); $this->connection->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, true); $this->connection->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); foreach($this->config['attr'] as $i3 => $i2) { $this->connection->setAttribute($i3, $i2); } if (isset($this->config['charset'])) { $this->connection->exec('SET NAMES ' . $this->config['charset']); } } return $this->connection; } public function getSchema() { return $this->config['dsn']['dbname']; } public function closeConnection() { $this->connection = NULL; } protected function __clone() { } }
 class Tii_Worker_Event_Select extends Tii_Worker_Event_Abstract { protected $read = []; protected $write = []; protected $scheduler = null; protected $timers = []; protected $timeout = 100000000; protected $channel = []; public function __construct() { $this->channel = stream_socket_pair(STREAM_PF_UNIX, STREAM_SOCK_STREAM, STREAM_IPPROTO_IP); if ($this->channel) { stream_set_blocking($this->channel[0], 0); $this->read[0] = $this->channel[0]; } $this->scheduler = new SplPriorityQueue(); $this->scheduler->setExtractFlags(SplPriorityQueue::EXTR_BOTH); } public function add($i, $i1, $i2, $i3 = []) { switch ($i1) { case self::EV_READ: $i4 = (int)$i; $this->events[$i4][$i1] = [$i2, $i]; $this->read[$i4] = $i; break; case self::EV_WRITE: $i4 = (int)$i; $this->events[$i4][$i1] = [$i2, $i]; $this->write[$i4] = $i; break; case self::EV_SIGNAL: $i4 = (int)$i; $this->signals[$i4][$i1] = [$i2, $i]; pcntl_signal($i, [$this, 'signalHandler']); break; case self::EV_TIMER: case self::EV_TIMER_ONCE: $i5 = microtime(true) + $i; $this->scheduler->insert(self::$id, -$i5); $this->timers[self::$id] = [$i2, $i3, $i1, $i]; $this->tick(); return self::$id++; } return true; } public function signalHandler($i) { call_user_func_array($this->signals[$i][self::EV_SIGNAL][0], [$i]); } public function delete($i, $i1) { $i2 = (int)$i; switch ($i1) { case self::EV_READ: unset($this->events[$i2][$i1], $this->read[$i2]); if (empty($this->events[$i2])) { unset($this->events[$i2]); } return true; case self::EV_WRITE: unset($this->events[$i2][$i1], $this->write[$i2]); if (empty($this->events[$i2])) { unset($this->events[$i2]); } return true; case self::EV_SIGNAL: unset($this->signals[$i2]); pcntl_signal($i, SIG_IGN); break; case self::EV_TIMER: case self::EV_TIMER_ONCE; unset($this->timers[$i2]); return true; } return false; } protected function tick() { while (!$this->scheduler->isEmpty()) { $i = $this->scheduler->top(); $i1 = $i['data']; $i2 = -$i['priority']; $i3 = microtime(true); $this->timeout = ($i2 - $i3) * 1000000; if ($this->timeout <= 0) { $this->scheduler->extract(); if (!isset($this->timers[$i1])) continue; list($i4, $i5, $i6, $i7) = $this->timers[$i1]; if ($i6 === self::EV_TIMER) { $i2 = $i3 + $i7; $this->scheduler->insert($i1, -$i2); } call_user_func_array($i4, $i5); if (isset($this->timers[$i1]) && $i6 === self::EV_TIMER_ONCE) { $this->delete($i1, self::EV_TIMER_ONCE); } continue; } return; } $this->timeout = 100000000; } public function clearAllTimer() { $this->scheduler = new SplPriorityQueue(); $this->scheduler->setExtractFlags(SplPriorityQueue::EXTR_BOTH); $this->timers = []; } public function loop() { $i = null; while (1) { pcntl_signal_dispatch(); $read = $this->read; $write = $this->write; $i1 = @stream_select($read, $write, $i, 0, $this->timeout); if (!$this->scheduler->isEmpty()) $this->tick(); if (!$i1) continue; foreach ($read as $i2) { $i3 = (int)$i2; if (isset($this->events[$i3][self::EV_READ])) { list($i4, $i5) = $this->events[$i3][self::EV_READ]; call_user_func_array($i4, [$i5]); } } foreach ($write as $i2) { $i3 = (int)$i2; if (isset($this->events[$i3][self::EV_WRITE])) { list($i4, $i5) = $this->events[$i3][self::EV_WRITE]; call_user_func_array($i4, [$i5]); } } } } }
 class Tii_Worker_Timer { protected static $tasks = []; protected static $event = null; public static function init($event = null) { if ($event) { self::$event = $event; } else { pcntl_signal(SIGALRM, ['Tii_Worker_Timer', 'signalHandler'], false); } } public static function signalHandler() { if (!self::$event) { pcntl_alarm(1); self::tick(); } } public static function add($i, $i1, $i2 = [], $i3 = true) { if ($i <= 0) { echo new Exception("bad time_interval"); return false; } if (!is_callable($i1) || !is_array($i2)) { echo new Exception("not callable or args not array"); return false; } if (self::$event) return self::$event->add( $i, $i3 ? Tii_Worker_Event::EV_TIMER : Tii_Worker_Event::EV_TIMER_ONCE, $i1, $i2 ); if (empty(self::$tasks)) pcntl_alarm(1); $i4 = time() + $i; isset(self::$tasks[$i4]) || self::$tasks[$i4] = []; self::$tasks[$i4][] = [$i1, $i2, $i3, $i]; return true; } public static function tick() { if (empty(self::$tasks)) { pcntl_alarm(0); return; } $i = time(); foreach (self::$tasks as $i1 => $tasks) { if ($i >= $i1) { foreach ($tasks as $i2) { list($i3, $i4, $i5, $i6) = $i2; try { call_user_func_array($i3, $i4); } catch (Exception $i7) { echo $i7; } if ($i5) self::add($i6, $i3, $i4); } unset(self::$tasks[$i1]); } } } public static function delete($i) { if (self::$event) return self::$event->delete($i, Tii_Worker_Event::EV_TIMER); return false; } public static function delAll() { self::$tasks = []; pcntl_alarm(0); if (self::$event) self::$event->clearAllTimer(); } }
 class Tii_Application_Processor_Cli extends Tii_Application_Processor_Abstract { protected $env = []; protected $macPattern = "|([0-9a-f][0-9a-f][:-]){5}[0-9a-f][0-9a-f]|i"; protected $ipPattern = "|([0-9]{1,3}\.){3}[0-9]{1,3}|i"; public function __construct() { parent::__construct(); $i = Tii::get('tii.application.rewrite.cli', []); if (count($i) > 0) { } $this->argvParser(); } protected function doBusyError($i, $i1) { echo Tii::get('tii.application.server.busy_error.message', 'Server too busy. Please try again later.'); exit; } public function getIp() { return Tii_Network::getIp(); } public function getMacAddr() { return Tii_Network::getMacAddr(); } public function getRequests() { return array_merge($this->getPairs(), $this->getEnvs()); } public function getRequest($i, $i1 = NULL) { return $this->getPair($i, $this->getEnv($i, $i1)); } public function getEnvs() { return $this->env; } public function getEnv($i, $i1 = NULL) { return Tii::valueInArray($this->env, $i, $i1); } public function getPid() { $i = posix_getpid(); $i || $i = getmypid(); return $i; } public function getResponse() { return Tii::object('Tii_Application_Processor_Cli_Response'); } private function argvParser() { if (!array_key_exists('argv', $_SERVER)) { $this->getResponse()->displayHelp(); } $i = $env = []; foreach ($_SERVER['argv'] as $i1 => $i2) { if ($i1 === 0) continue; if (substr($i2, 0, 2) == '--') { $i2 = substr($i2, 2); if (strpos($i2, '=') === false) { $env[$i2] = true; } else { list($i3, $i4) = explode('=', $i2, 2); $env[$i3] = $i4; } } else { $i[] = $i2; } } $this->setPairs($i); $this->env = $env; $i = array_pad($i, 3, NULL); $i5 = array_shift($i); $i6 = array_shift($i); $i7 = array_shift($i); $this->setModuleName($i5); $this->setControllerName($i6); $this->setActionName($i7); } public function over() {} }
 class Tii_Worker_Connection_Tcp extends Tii_Worker_Connection_Abstract { const READ_BUFFER_SIZE = 65535; const STATUS_INITIAL = 0; const STATUS_CONNECTING = 1; const STATUS_ESTABLISH = 2; const STATUS_CLOSING = 4; const STATUS_CLOSED = 8; public $id = 0; public $maxSendBufferSize = 1048576; public $maxPackageSize = 10485760; protected static $idRecorder = 1; protected $sendBuffer = ''; protected $recvBuffer = ''; protected $currentPackageLength = 0; protected $status = self::STATUS_ESTABLISH; protected $isPaused = false; public $worker; public function __construct($i, $i1, $worker = NULL) { parent::__construct($i, $i1); self::$statistics['connection_count']++; $this->id = self::$idRecorder++; stream_set_blocking($this->socket, 0); if (function_exists('stream_set_read_buffer')) { stream_set_read_buffer($this->socket, 0); } Tii_Worker::$events->add($this->socket, Tii_Worker_Event::EV_READ, [$this, 'baseRead']); $this->maxSendBufferSize = Tii_Worker::$init['connection']['default_max_send_buffer_size']; $this->maxPackageSize = Tii_Worker::$init['connection']['max_package_size']; if ($worker) { $this->worker = $worker; $this->maxSendBufferSize = Tii::valueInArray($worker->connection, 'default_max_send_buffer_size', 1048576); $this->maxPackageSize = Tii::valueInArray($worker->connection, 'max_package_size', 1048576); } } public function send($i, $i1 = false) { if (false === $i1 && $this->protocol) { $i = $this->protocol->encode($i, $this); if ($i === '') { return null; } } if ($this->status === self::STATUS_INITIAL || $this->status === self::STATUS_CONNECTING) { $this->sendBuffer .= $i; return null; } elseif ($this->status === self::STATUS_CLOSING || $this->status === self::STATUS_CLOSED) { return false; } if ($this->sendBuffer === '') { $i2 = @fwrite($this->socket, $i); if ($i2 === strlen($i)) { return true; } if ($i2 > 0) { $this->sendBuffer = substr($i, $i2); } else { if (!is_resource($this->socket) || feof($this->socket)) { self::$statistics['send_fail']++; $this->onError(Tii_Worker::E_SEND_FAIL, 'client closed'); $this->destroy(); return false; } $this->sendBuffer = $i; } Tii_Worker::$events->add($this->socket, Tii_Worker_Event::EV_WRITE, [$this, 'baseWrite']); $this->checkBufferIsFull(); return null; } else { if ($this->maxSendBufferSize <= strlen($this->sendBuffer)) { self::$statistics['send_fail']++; $this->onError(Tii_Worker::E_SEND_FAIL, 'send buffer full and drop package'); return false; } $this->sendBuffer .= $i; $this->checkBufferIsFull(); } } public function pauseRecv() { Tii_Worker::$events->delete($this->socket, Tii_Worker_Event::EV_READ); $this->isPaused = true; } public function resumeRecv() { if ($this->isPaused === true) { Tii_Worker::$events->add($this->socket, Tii_Worker_Event::EV_READ, [$this, 'baseRead']); $this->isPaused = false; $this->baseRead($this->socket, false); } } public function baseRead($i, $i1 = true) { $i2 = fread($i, self::READ_BUFFER_SIZE); if ($i2 === '' || $i2 === false) { if ($i1 && (feof($i) || !is_resource($i) || $i2 === false)) { $this->destroy(); return; } } else { $this->recvBuffer .= $i2; } if ($this->protocol) { while ($this->recvBuffer !== '' && !$this->isPaused) { if ($this->currentPackageLength) { if ($this->currentPackageLength > strlen($this->recvBuffer)) { break; } } else { $this->currentPackageLength = call_user_func_array($this->protocol->input, [$this->recvBuffer, $this]); if ($this->currentPackageLength === 0) { break; } elseif ($this->currentPackageLength > 0 && $this->currentPackageLength <= $this->maxPackageSize) { if ($this->currentPackageLength > strlen($this->recvBuffer)) { break; } } else { echo 'error package. package_length=' . var_export($this->currentPackageLength, true); $this->destroy(); return; } } self::$statistics['total_request']++; if (strlen($this->recvBuffer) === $this->currentPackageLength) { $i3 = $this->recvBuffer; $this->recvBuffer = ''; } else { $i3 = substr($this->recvBuffer, 0, $this->currentPackageLength); $this->recvBuffer = substr($this->recvBuffer, $this->currentPackageLength); } $this->currentPackageLength = 0; $this->onMessage($this->protocol->decode($i3, $this)); } return; } if ($this->recvBuffer === '' || $this->isPaused) { return; } self::$statistics['total_request']++; if (!$this->onMessage) { $this->recvBuffer = ''; return; } $this->onMessage($this->recvBuffer); $this->recvBuffer = ''; } public function baseWrite() { $i = @fwrite($this->socket, $this->sendBuffer); if ($i === strlen($this->sendBuffer)) { Tii_Worker::$events->delete($this->socket, Tii_Worker_Event::EV_WRITE); $this->sendBuffer = ''; $this->onBufferDrain(); if ($this->status === self::STATUS_CLOSING) { $this->destroy(); } return true; } if ($i > 0) { $this->sendBuffer = substr($this->sendBuffer, $i); } else { self::$statistics['send_fail']++; $this->destroy(); } } public function pipe($i) { $i1 = $this; $this->onMessage = function ($i1, $i2) use ($i) { $i->send($i2); }; $this->onClose = function ($i1) use ($i) { $i->destroy(); }; $i->onBufferFull = function ($i) use ($i1) { $i1->pauseRecv(); }; $i->onBufferDrain = function ($i) use ($i1) { $i1->resumeRecv(); }; } public function consumeRecvBuffer($i) { $this->recvBuffer = substr($this->recvBuffer, $i); } public function close($i = null, $i1 = false) { if (in_array($this->status, [self::STATUS_CLOSING, self::STATUS_CLOSED])) { return; } else { if ($i !== null) $this->send($i, $i1); $this->status = self::STATUS_CLOSING; } if ($this->sendBuffer === '') $this->destroy(); } public function getSocket() { return $this->socket; } protected function checkBufferIsFull() { if ($this->maxSendBufferSize <= strlen($this->sendBuffer)) { $this->onBufferFull(); } } public function destroy() { if ($this->status === self::STATUS_CLOSED) return; Tii_Worker::$events->delete($this->socket, Tii_Worker_Event::EV_READ); Tii_Worker::$events->delete($this->socket, Tii_Worker_Event::EV_WRITE); @fclose($this->socket); if ($this->worker) { unset($this->worker->connections[$this->id]); } $this->status = self::STATUS_CLOSED; $this->onClose(); if ($this->protocol) $this->protocol->onClose($this); if ($this->status === self::STATUS_CLOSED) { $this->onMessage = $this->onClose = $this->onError = $this->onBufferFull = $this->onBufferDrain = null; } } public function __destruct() { self::$statistics['connection_count']--; } }
 class Tii_Cache_Memcache extends Tii_Cache_Abstract { private $memcache; private $isSupported = false; public function __construct() { if (class_exists('Memcache')) { $this->memcache = new Memcache; $i = (array)Tii::get('tii.cache.memcache', []); $i1 = false; foreach ($i as $i2 => $i3) { if (call_user_func_array([$this->memcache, 'addServer'], $i3)) { $i1 = true; } } if ($i1) { $this->isSupported = true; } else { $this->isSupported = $this->memcache->set("Tii_Cache_Memcache.isSupported", true); } } } public function isSupported() { return $this->isSupported; } public function addServer() { $i = func_get_args(); return call_user_func_array([$this->memcache, 'addServer'], $i); } public function set($i, $i1, $i2 = 0, $i3 = 0) { return $this->memcache->set($i, $i1, $i2 ? MEMCACHE_COMPRESSED : NULL, $i3); } public function add($i, $i1, $i2 = 0, $i3 = 0) { return $this->memcache->add($i, $i1, $i2 ? MEMCACHE_COMPRESSED : NULL, $i3); } public function replace($i, $i1, $i2 = 0, $i3 = 0) { return $this->memcache->replace($i, $i1, $i2 ? MEMCACHE_COMPRESSED : NULL, $i3); } public function increment($i, $i1 = 1) { return $this->memcache->increment($i, intval($i1)); } public function decrement($i, $i1 = 1) { return $this->memcache->decrement($i, intval($i1)); } public function get($i) { return $this->memcache->get($i); } public function delete($i, $i1=0) { return $this->memcache->delete($i, $i1); } public function lock($i, $i1 = 60) { if ($this->get($i)) { return false; } ignore_user_abort(true); return $this->set($i, true, 0, $i1); } public function unlock($i) { if (!$this->get($i)) { return false; } return $this->delete($i); } public function flush() { $this->memcache->flush(); } public function getExtendedStats($i = NULL, $i1 = NULL, $i2 = 100) { return $this->memcache->getStats($i, $i1, $i2); } }
 class Tii_Cache_File extends Tii_Cache_Abstract { private $lockers = []; private $configs; public function __construct() { $this->configs = (object) array_merge([ 'directory' => Tii::get('tii.temp_dir'), 'gc_probality' => 1, ], Tii::get('tii.cache.file', []) ); $this->configs->gc_probality = [true => $this->configs->gc_probality, false => (100-$this->configs->gc_probality)]; Tii_Filesystem::mkdir($this->configs->directory); } public function isSupported() { static $i; is_bool($i) || $i = Tii_Filesystem::isWritable($this->configs->directory); return $i; } public function getFilename($i, $i1 = false) { $i2 = Tii_Filesystem::hashfile($i, 'cached'); $i1 && Tii_Math::getScaleRandom($this->configs->gc_probality) && $this->gc(dirname($i2)); return $i2; } public function set($i, $i1, $i2 = 0, $i3 = 0) { $i3 || $i3 = 31536000; $i4 = [ 'expired' => time() + $i3, 'data' => $i1, ]; $i5 = $this->getFilename($i, true); file_put_contents($i5, serialize($i4), LOCK_EX); clearstatcache(); return Tii_Filesystem::touch($i5, $i4['expired']); } public function add($i, $i1, $i2 = 0, $i3 = 0) { if (is_file($this->getFilename($i))) return false; return $this->set($i, $i1, $i2, $i3); } public function replace($i, $i1, $i2 = 0, $i3 = 0) { if (!is_file($this->getFilename($i))) return false; return $this->set($i, $i1, $i2, $i3); } public function increment($i, $i1 = 1) { $i1 = intval($this->get($i)) + $i1; return $this->set($i, $i1); } public function decrement($i, $i1 = 1) { $i1 = intval($this->get($i)) - $i1; return $this->set($i, $i1); } public function get($i) { if (is_array($i)) { $i1 = []; foreach ($i as $i2) { $i1[$i2] = $this->get($i2); } return $i1; } $i3 = $this->getFilename($i); if (!is_file($i3)) return NULL; $i4 = file_get_contents($i3); $i5 = unserialize($i4); if (!isset($i5['expired'])) { $this->delete($i); return NULL; } if ($i5['expired'] && $i5['expired'] < time()) { $this->delete($i); return NULL; } return $i5['data']; } public function delete($i, $i1 = 0) { return Tii_Filesystem::unlink($this->getFilename($i)); } public function lock($i, $i1 = 60) { $i2 = fopen($this->getFilename($i), "w+"); if ($i2 === false) return false; ignore_user_abort(true); $this->lockers[$i] = $i2; return flock($i2, LOCK_EX); } public function unlock($i) { $i1 = false; if (isset($this->lockers[$i]) && ($i2 = $this->lockers[$i]) !== false) { $i1 = flock($i2, LOCK_UN); fclose($i2); } return $i1; } protected function gc($i) { foreach(Tii_Filesystem::getFiles($i) as $i1) { if (time() < filemtime($i1)) continue; Tii_Filesystem::unlink($i1); } } public function flush() { foreach (Tii_Filesystem::getFiles($this->configs->directory) as $i) { Tii_Filesystem::unlink($i); } foreach (Tii_Filesystem::getFolders($this->configs->directory) as $i1) { Tii_Filesystem::rmdir($i1); } } }
 class Tii_Worker_Connection_Udp extends Tii_Worker_Connection_Abstract { public function send($i, $i1 = false) { if (false === $i1 && $this->protocol) { $i = $this->protocol->encode($i, $this); if ($i === '') { return null; } } return strlen($i) === stream_socket_sendto($this->socket, $i, 0, $this->remoteAddress); } public function close($i = null, $i1 = false) { if ($i !== null) { $this->send($i, $i1); } return true; } }
 class Tii_Worker_Connection_Async extends Tii_Worker_Connection_Tcp { public $transport = 'tcp'; protected $status = self::STATUS_INITIAL; protected $remoteHost = ''; protected $remoteURI = ''; protected $connectStartTime = 0; protected $runtime = []; public function __get($i) { return Tii::valueInArray($this->runtime, $i); } public function getProtocols() { return Tii_Event::filter('tii.worker.protocols', Tii::valueInArray($this->runtime, 'protocols', [])); } public function __construct($i, $runtime = []) { $i1 = parse_url($i); if (!isset($i1['host'])) { throw new Tii_Exception("bad remote_address: `%s'", $i); } else { $this->remoteAddress = sprintf("%s:%s", $i1['host'], Tii::valueInArray($i1, 'port', 80)); $this->remoteHost = $i1['host']; $this->remoteURI = Tii_Http::urlAppend( Tii::valueInArray($i1, 'path', '/'), Tii::valueInArray($i1, 'query') ); $i2 = Tii::valueInArray($i1, 'scheme', 'tcp'); } $this->runtime = array_replace_recursive(Tii_Worker::$init, Tii::get('tii.worker', []), $runtime); if (!isset($this->builtin_transports[$i2])) { $i3 = $this->getProtocols(); if (!isset($i3[$i2])) { throw new Tii_Exception("Protocol %s not exist", $i2); } $this->protocol = new Tii_Worker_Protocol($i3[$i2]); } else { $this->transport = $this->builtin_transports[$i2]; } $this->id = self::$idRecorder++; self::$statistics['connection_count']++; $this->maxSendBufferSize = Tii::valueInArray($this->connection, 'default_max_send_buffer_size', 1048576); } public function connect() { if (!in_array($this->status, [self::STATUS_INITIAL, self::STATUS_CLOSING, self::STATUS_CLOSED])) { return; } $this->status = self::STATUS_CONNECTING; $this->connectStartTime = microtime(true); $this->socket = stream_socket_client("{$this->transport}://{$this->remoteAddress}", $i, $i1, 0, STREAM_CLIENT_ASYNC_CONNECT); if (!$this->socket) { $this->emitError(WORKERMAN_CONNECT_FAIL, $i1); if ($this->status === self::STATUS_CLOSING) { $this->destroy(); } if ($this->status === self::STATUS_CLOSED) { $this->onConnect = null; } return; } Tii_Worker::$events->add($this->socket, Tii_Worker_Event::EV_WRITE, [$this, 'checkConnection']); } public function getRemoteHost() { return $this->remoteHost; } public function getRemoteURI() { return $this->remoteURI; } protected function emitError($i, $i1) { $this->status = self::STATUS_CLOSING; $this->onError($i, $i1); } public function checkConnection($i) { if ($i1 = stream_socket_get_name($i, true)) { Tii_Worker::$events->delete($i, Tii_Worker_Event::EV_WRITE); stream_set_blocking($i, 0); if (function_exists('stream_set_read_buffer')) { stream_set_read_buffer($i, 0); } if (function_exists('socket_import_stream') && $this->transport === 'tcp') { $i2 = socket_import_stream($i); socket_set_option($i2, SOL_SOCKET, SO_KEEPALIVE, 1); socket_set_option($i2, SOL_TCP, TCP_NODELAY, 1); } Tii_Worker::$events->add($i, Tii_Worker_Event::EV_READ, [$this, 'baseRead']); if ($this->sendBuffer) { Tii_Worker::$events->add($i, Tii_Worker_Event::EV_WRITE, [$this, 'baseWrite']); } $this->status = self::STATUS_ESTABLISH; $this->remoteAddress = $i1; $this->onConnect(); if ($this->protocol) $this->protocol->onConnect($this); } else { $this->emitError(Tii_Worker::E_CONNECT_FAIL, 'connect ' . $this->remoteAddress . ' fail after ' . round(microtime(true) - $this->connectStartTime, 4) . ' seconds'); if ($this->status === self::STATUS_CLOSING) { $this->destroy(); } if ($this->status === self::STATUS_CLOSED) { $this->onConnect = null; } } } }
 abstract class Tii_Worker_Abstract { public $worker; public function __construct($i = '', $i1 = [], $i2 = [], $i3 = NULL) { $worker = new Tii_Worker($i, $i1, $i2, $i3); foreach(Tii::properties('Tii_Worker', '|^on|') as $i4) { if (method_exists($this, $i4)) { $worker->{$i4} = [$this, $i4]; } } $this->worker = $worker; } public static function run() { $i = get_called_class(); new $i; Tii_Worker::$globalStart || Tii_Worker::run(); } }
 final class Tii_Time { public static function timezone($i = 'UTC') { @date_default_timezone_set($i); } public static function micro() { return microtime(true); } public static function milli() { return ceil(self::micro() * 1000); } public static function now($i = false) { return $i ? self::online() : self::locale(); } public static function online() { $i = Tii::get('tii.time.servers', ["time.nist.gov", "time-d.nist.gov"]); foreach ($i as $i1) { $i2 = @fsockopen($i1, 37, $i3, $i4, 0.5); if (!$i2) continue; stream_set_timeout($i2, 0, 500); $i5 = stream_get_meta_data($i2); if ($i5['timed_out']) { @fclose($i2); continue; } $i6 = NULL; while (!feof($i2)) { $i6 .= fgets($i2, 128); } fclose($i2); if (strlen($i6) != 4) continue; $i7 = ord($i6{0})*pow(256, 3) + ord($i6{1})*pow(256, 2) + ord($i6{2})*256 + ord($i6{3}); return $i7 - 2208988800; } return 0; } public static function locale() { return time(); } public static function totime($i = NULL, $i1 = NULL) { if (empty($i)) return self::now(); if (is_numeric($i)) return $i; if (empty($i1)) return strtotime($i); if (is_numeric($i1)) return strtotime($i, $i1); return strtotime($i, self::totime($i1)); } public static function format($i = 'Y-m-d H:i:s', $i1 = NULL, $i2 = NULL) { return date($i, self::totime($i1, $i2)); } public static function formatted($i, $i1 = NULL, $i2 = NULL) { return self::totime(self::format($i, $i1, $i2)); } public static function interval($i, $i1 = NULL) { return self::totime($i1) - self::totime($i); } public static function inSeconds($i, $i1 = -60, $i2 = 60, $i3 = NULL) { return ($i4 = self::interval($i, $i3)) >= $i1 && $i4 <= $i2; } public static function readable($i, $i1 = '%.3f%s', $i2 = 3) { if ($i >= 1) { $i3 = 's'; $i4 = round($i, $i2); } else { $i3 = 'ms'; $i4 = round($i * 1000); $i1 = preg_replace('/(%.[\d]+f)/', '%d', $i1); } return sprintf($i1, $i4, Tii::lang($i3)); } public static function nexttime($i = '* * * * *', $i1 = NULL, $i2 = NULL) { $i = preg_split("/[\s]+/i", trim($i)); switch(count($i)) { case 5: break; case 6: case 7: array_shift($i); break; default: return NULL; } $i3 = self::formatted('Y-m-d H:i', $i1, $i2); $i4 = 60*60*24*366; $i5 = []; $i6 = [ 'i' =>self::_parseCronNumbers($i[0], 0, 59), 'G' =>self::_parseCronNumbers($i[1], 0, 23), 'n' =>self::_parseCronNumbers($i[3], 1, 12), 'w' =>self::_parseCronNumbers($i[4], 0, 6), ]; while($i3 > $i4) { $i3 = $i3 + 60; list($i7, $i8, $i9, $iA, $iB, $iC) = array_map(function($iB){return intval($iB);}, explode(',', date("Y,n,j,G,i,w", $i3))); $iD = $i7.'-'.$i8; isset($i5[$iD]) || $i5[$iD] = self::_parseCronNumbers($i[2], 1, self::format('t', $iD)); $i6['j'] = $i5[$iD]; if (isset($i6['i'][$iB], $i6['G'][$iA], $i6['n'][$i8])) { if (isset($i6['w'][$iC]) || isset($i6['j'][$i9])) return $i3; } } return NULL; } protected static function _parseCronNumbers($i, $i1, $i2) { if ($i == '?') return []; $i3 = []; $i4 = explode(',', $i);print_r($i4); foreach($i4 as $i5) { $i6 = explode('/', $i5); $i7 = empty($i6[1]) ? 1 : $i6[1]; $i8 = explode('-', $i6[0]); $i9 = intval(count($i8) == 2 ? $i8[0] : ($i6[0] == '*' ? $i1 : $i6[0])); $iA = intval(count($i8) == 2 ? $i8[1] : ($i6[0] == '*' ? $i2 : $i6[0])); if ($i9 > $iA) { for ($iB = $i1; $iB <= $iA; $iB += $i7) { $i3[$iB] = intval($iB); } for ($iB = $i9; $iB <= $i2; $iB += $i7) { $i3[$iB] = intval($iB); } } else { for ($iB = $i9; $iB <= $iA; $iB += $i7) { $i3[$iB] = intval($iB); } } } ksort($i3); return $i3; } }
 final class Tii_Timer { const MIN_RESOLUTION = 0.001; private $running = false; private $time; private $active = []; private $timers; private $sequenceId = 0; public function __construct() { $this->timers = new SplPriorityQueue(); } public function updateTime() { return $this->time = microtime(true); } public function getTime() { return $this->time ?: $this->updateTime(); } private function getScheduled($i, $time) { if (is_numeric($i)) { return $i + $time; } else { return Tii_Time::nexttime($i, $time); } } public function add($i, $i1 = self::MIN_RESOLUTION, $i2 = false) { if (is_numeric($i1)) { if ($i1 < self::MIN_RESOLUTION) { throw new Tii_Exception("interval need to numeric and is greater than %s", self::MIN_RESOLUTION); } } else if(is_string($i1)) { if (!Tii_Time::nexttime($i1)) { throw new Tii_Exception("invalid crontab expression error"); } } else { throw new Tii_Exception("interval error, numeric or crontab expression"); } if (!is_callable($i)) { throw new Tii_Exception("The callback must be a callable object"); } $i3 = (object) [ 'interval' => $i1, 'callback' => $i, 'periodic' => $i2, 'scheduled' => $this->getScheduled($i1, $this->getTime()), ]; $i3->signature = spl_object_hash($i3); $this->timers->insert($i3, -$i3->scheduled); $this->active[$i3->signature] = $i3; return $i3->signature; } public function addPeriodic($i, $i1 = self::MIN_RESOLUTION) { return $this->add($i, $i1, true); } public function cancel($i) { unset($this->active[$i]); } public function getFirst() { if ($this->timers->isEmpty()) { return NULL; } return $this->timers->top()->scheduled; } public function isEmpty() { return !$this->active; } public function tick() { $time = $this->updateTime(); $timers = $this->timers; while (!$timers->isEmpty() && $timers->top()->scheduled < $time) { $i = $timers->extract(); if (isset($this->active[$i->signature])) { call_user_func($i->callback, $i->signature, ++$this->sequenceId); if ($i->periodic === true) { $i->scheduled = $this->getScheduled($i->interval, $time); $timers->insert($i, -$i->scheduled); } else { unset($this->active[$i->signature]); } } } return $this->running; } public function run($i = 0) { $this->start(); if ($i > 0) { $i1 = $this; $this->add(function() use ($i1) {$i1->stop();}, $i); } while ($this->tick()) { } } public function start() { $this->running = true; } public function stop() { $this->running = false; } }
?>